<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="ODE Tutorial" href="ODEGuide.html" /><link rel="prev" title="Python: Installing ASSET" href="Installation.html" />

    <meta name="generator" content="sphinx-4.2.0, furo 2022.09.29"/>
        <title>Vector Function Tutorial - ASSET 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: red;
  --color-brand-content: #CC3333;
  --color-admonition-background: orange;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ASSET 0.0.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">ASSET 0.0.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="tutorials.html">Tutorials</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Installation.html">Python: Installing ASSET</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Vector Function Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ODEGuide.html">ODE Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="IntegratorGuide.html">Integrator Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="PhaseGuide.html">Optimal Control Phase Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptimalControlProblem.html">Optimal Control Problem Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="PSIOPT.html">PSIOPT</a></li>
<li class="toctree-l2"><a class="reference internal" href="Phase.html">Phase Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="VectorFunctions_tutorial.html">Python: Vector Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Integrator.html">Integrators</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../examples/examples.html">Examples</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples/halo.html">Example 1: Orbit Family Continuation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/zermelo.html">Example 2a: Zermelo’s Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/zermelolink.html">Example 2b: Multi-Phase Zermelo’s Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/MultiTarg.html">Example 3: Multi-Spacecraft Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Delta3.html">Delta 3 Multi-phase GTO Transfer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ReentryExample.html">Space Shuttle Reentry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/CartPole.html">Cart Pole Swing Up</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../python/python.html">Python Library Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../python/asset.html">ASSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/optimalcontrol.html">Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/vectorfunctions.html">Vector Functions</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="vector-function-tutorial">
<h1>Vector Function Tutorial<a class="headerlink" href="#vector-function-tutorial" title="Permalink to this headline">#</a></h1>
<p>One of the goals of ASSET is to provide the ability to users to construct functions
dynamically within Python that are able to be used by ASSET. By doing this we can simplify a user’s work-flow,
where the benefits of high speed C++ code can be combined with the ease of use Python provides.
In this section we will give an depth overview of ASSET’s vector function type. At high-level,
this is simple functional (in the programming sense) domain specific language for defining
mathematical Vector Functions that take a fixed number of inputs
and produce a fixed number outputs, with both inputs and outputs assumed to be column vectors.</p>
<section id="arguments">
<h2>Arguments<a class="headerlink" href="#arguments" title="Permalink to this headline">#</a></h2>
<p>To start let is import asset and the vector functions module which contains all types
and functions defining the language. From this module we will then import the Arguments type
and give it a shorthand name. The <code class="code docutils literal notranslate"><span class="pre">Arguments</span></code> type is the base expression in the vector function system
and represents a function that simply takes some number of input arguments and returns them as outputs.
It always serves as the starting point for defining a more complicated functional expressions involving
some or all of its outputs.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">vf</span>        <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">VectorFunctions</span>
<span class="n">Args</span>      <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">Arguments</span>
</pre></div>
</div>
<p>We can construct the object by simply specifying the number of arguments, in this
case 6. This instance <code class="code docutils literal notranslate"><span class="pre">X</span></code> is now a first class function thats takes any vector of size 6
and returns that vector. Since it is a vector function we can compute is output value using the
<code class="code docutils literal notranslate"><span class="pre">()</span></code> operator,first derivative using the <code class="code docutils literal notranslate"><span class="pre">.jacobian</span></code> method and second derivative using the <code class="code docutils literal notranslate"><span class="pre">.adjointhessian</span></code> method.
To do this we provide either a numpy vector or python list of real valued inputs, and additionally for the second derivative
a vector of list of lagrange multipliers with same dimensions as the output of the function. One important note, ASSET does not compute
the full 3D tensor second derivative of vector valued functions, instead it computes the second derivative
dotted with a vector lagrange multipliers, resulting in 2D symmetric matrix with rows and columns equal to the number of inputs.
We refer to this as the adjointhessian, and in the case of a function with a single output is equivalent to the normal hessian.
Since <code class="code docutils literal notranslate"><span class="pre">X</span></code> here is a simple linear function, the first derivative is simply the identity matrix and the adjointhessian is zero. This is
a rather trivial example, but the same methods can applied to any asset vector function that we can construct. We should also note that while
these methods are available for all vector functions, for most applications and examples you wont ever actually need to explicitly
call the function or its derivatives at real arguments as that will be handled for you by some other interface such as an integrator or optimal
control problem.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="n">lvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">6</span><span class="p">))</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span> <span class="n">X</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#prints [0,1,2,3,4,5]</span>

<span class="nb">print</span><span class="p">(</span> <span class="n">X</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#prints Identiy matrix of size 6</span>

<span class="nb">print</span><span class="p">(</span> <span class="n">X</span><span class="o">.</span><span class="n">adjointhessian</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span><span class="n">lvals</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#prints zero matrix of size 6</span>
</pre></div>
</div>
<p>As you can see, <code class="code docutils literal notranslate"><span class="pre">Arguments</span></code> itself does not do any thing very interesting, but what it does do is
serve as a starting point for defining functions of elements and sub-vectors. For example, we may
make a new object referencing one of its elements by using the bracket operator. This will return an object of
another fundamental type, <code class="code docutils literal notranslate"><span class="pre">Element</span></code>, which is itself a function that takes all input arguments and returns the specified
element as a scalar output. Attempting to address an element out of bounds of the <code class="code docutils literal notranslate"><span class="pre">Arguments</span></code> will immediately throw an
error at the offending operation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">x0</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">x5</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">#x42 =X[42]  #throws an error</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1"># prints [0.0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x5</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1"># prints [5.0]</span>
</pre></div>
</div>
<p>Often times you will write an expression where the Arguments represent many separate
distinct scalar elements that will be combined to construct a more complicated expression.
In this case, we can bypass the many lines necessary to index them individually, by using
the <code class="code docutils literal notranslate"><span class="pre">.tolist()</span></code> method of Arguments. This method will return all the individual elements concatenated
in order inside of a single python list, which we can then unpack into individual named elements in a single line.
You may use whatever method you wish, but we personally prefer the <code class="code docutils literal notranslate"><span class="pre">.tolist()</span></code> method in this case.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">x0</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">x4</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">x5</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">## Equivalent to</span>

<span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">,</span><span class="n">x5</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>
</div>
<p>In addition to scalar Elements, one may also address contiguous sub-vectors in a set of arguments
using the <code class="code docutils literal notranslate"><span class="pre">.head()</span></code>, <code class="code docutils literal notranslate"><span class="pre">.tail()</span></code>, and <code class="code docutils literal notranslate"><span class="pre">.segment()</span></code> methods of <code class="code docutils literal notranslate"><span class="pre">Arguments</span></code>, or standard python (contiguous) list indexing.
For example, if we want to treat the first three arguments of the Arguments below as a single vector R, we can
use the <code class="code docutils literal notranslate"><span class="pre">.head(n)</span></code> method. The <code class="code docutils literal notranslate"><span class="pre">.head(n)</span></code> method returns a sub-vector of size <code class="code docutils literal notranslate"><span class="pre">n</span></code> starting at the first element. This syntax mirrors the
Eigen C++ library, which we find to be quite nice, but you may also use standard python list indexing to accomplish the same
goal. Similarly, if we want to address the last three arguments as a single vector V , we can use the <code class="code docutils literal notranslate"><span class="pre">.tail(n)</span></code> method which returns
the last <code class="code docutils literal notranslate"><span class="pre">n</span></code> elements of some arguments. Finally we can address vectors of length n starting at index <code class="code docutils literal notranslate"><span class="pre">i</span></code>
using the <code class="code docutils literal notranslate"><span class="pre">.segment(i,n)</span></code> method. The return type of all of these methods is the fundamental <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> type, which is a function that returns
as its output the specified sub-vector of the arguments.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>    <span class="c1"># Same as above</span>

<span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span> <span class="c1">#prints [1,2,3]</span>


<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>    <span class="c1"># same as above</span>

<span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [4,5,6]</span>


<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># same as R above</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># same as V above</span>


<span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># first argument is starting index, second is size</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>         <span class="c1">#same as above but python style</span>

<span class="nb">print</span><span class="p">(</span><span class="n">N</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>    <span class="c1"># prints [2,3,4,5]</span>
</pre></div>
</div>
<p>Paralleling what we did before with elements we can also partition an input argument list
list into segments and elements using the <code class="code docutils literal notranslate"><span class="pre">.tolist([(start,size),</span> <span class="pre">..])</span></code> method. In this case we should
pass a python list of tuples, where the first element of each tuple is the starting index of the sub-vector
and the second is the size, sub-vectors of size one are returned as elements. Note that this method does not
require you to partition all of the argument set, though this example does. Furthermore, it is not
required that the sub-vectors specified be in any particular order, though we highly recommend you sort them
according to starting index.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>

<span class="c1">## Equivalent to the Above</span>
<span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">])</span>



<span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span> <span class="c1">#prints [1,2,3]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [4,5,6]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [7]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [8]</span>
</pre></div>
</div>
<p>Finally, all of the above indexing methods behave exactly the same when applied
to segments rather than arguments, and we can address their individual components
as elements, and split them in smaller segments. For example, we may split <code class="code docutils literal notranslate"><span class="pre">R</span></code> into
its scalar components using <code class="code docutils literal notranslate"><span class="pre">.tolist</span></code>, address a single component using brackets, or a subsegment
using head,tail,segment etc..</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">r0</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">r0</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints([1])</span>

<span class="n">v0</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">v0</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints([4])</span>

<span class="n">V12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">V12</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints([5,6])</span>
</pre></div>
</div>
</section>
<section id="standard-math-operations">
<h2>Standard Math Operations<a class="headerlink" href="#standard-math-operations" title="Permalink to this headline">#</a></h2>
<p>Having covered most everything related to constructing arguments, and their elements
and sub-vectors, we can move on the to combining them together into meaningful mathematical functions.
We should note that the result of any mathematical non indexing operation will have
the generic type <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> (more than one output) or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code> (one output),
which themselves may be operated on and combined with the three
fundamental types using the same rules. In general, types will be converted automatically, and
users should not concern themselves with the types of resulting expressions
and should only make sure that their expressions are mathematically consistent.
We may add subtract multiply, and divide functions by other functions and numerical constants using
the standard rules of vector math. For example,
we may add or subtract two functions of the same output size to together, add or subtract vectors
of constants or constant scalars, multiply functions by constant scalars, multiply functions by Scalar functions, etc.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">5.0</span>

<span class="n">RpV</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="n">V</span>

<span class="n">RmC</span> <span class="o">=</span> <span class="n">R</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>

<span class="n">Rtv0</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">RtC</span>   <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="mi">2</span>

<span class="n">RdC</span>   <span class="o">=</span> <span class="n">R</span><span class="o">/</span><span class="mi">2</span>

<span class="n">Vdr0</span> <span class="o">=</span> <span class="n">V</span><span class="o">/</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">N</span> <span class="o">=</span> <span class="n">Rtv0</span> <span class="o">+</span> <span class="n">RdC</span>

<span class="n">v1pv0</span> <span class="o">=</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">9.0</span><span class="p">)</span><span class="o">*</span><span class="mf">2.0</span>

<span class="n">inv0</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">v0</span>
</pre></div>
</div>
<p>As this is a vector math language, certain operations involving vectors are not
allowed via standard multiply and divide operator overloads. For example one may
not multiply two VectorFunctions together using the * operator as is possible with two arrays in numpy.
This is an explicit choice because in our opinion, for the types of expressions written using asset,
allowing element-wise vector multiplication creates more problems in terms incorrect problem formulation than it solves.
However, these operations can be accomplished using methods we describe later.Note,
this does not apply to scalar functions such as <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code>, which may be multiplied together with
no issue, and may also scale in VectorFunction.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">## RmV = R*V  # Throws and Error</span>
<span class="c1">## RdV = R/V  # Throws and Error</span>
</pre></div>
</div>
</section>
<section id="scalar-math-operations">
<h2>Scalar Math Operations<a class="headerlink" href="#scalar-math-operations" title="Permalink to this headline">#</a></h2>
<p>Next we will move on to describe the standard mathematical functions that can be applied to scalar
valued functions. These encompass most of the standard functions that can be found in python or C math libraries,
such as sin, cos, tan etc. All of these functions are stored inside the VectorFunctions module (which we have imported as <code class="code docutils literal notranslate"><span class="pre">vf</span></code>),
and can be called as shown below. A complete list of functions is given in the table below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">cosh</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">3.14</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># power operator</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">h</span>  <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="table-wrapper colwidths-given docutils container" id="id3">
<table class="colwidths-given docutils align-default" id="id3">
<caption><span class="caption-text">List of Scalar Math Functions</span><a class="headerlink" href="#id3" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.sin(f)</span></code></p></td>
<td><p>Returns the sine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.cos(f)</span></code></p></td>
<td><p>Returns the cosine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.tan(f)</span></code></p></td>
<td><p>Returns the tangent of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arcsin(f)</span></code></p></td>
<td><p>Returns the inverse sine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arccos(f)</span></code></p></td>
<td><p>Returns the inverse cosine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arctan(f)</span></code></p></td>
<td><p>Returns the inverse tangent of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.sinh(f)</span></code></p></td>
<td><p>Returns the hyperbolic sine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.cosh(f)</span></code></p></td>
<td><p>Returns the hyperbolic cosine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.tanh(f)</span></code></p></td>
<td><p>Returns the hyperbolic tangent of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arcsinh(f)</span></code></p></td>
<td><p>Returns the inverse  hyperbolic sine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arccosh(f)</span></code></p></td>
<td><p>Returns the inverse  hyperbolic cosine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arctanh(f)</span></code></p></td>
<td><p>Returns the inverse  hyperbolic tangent of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.log(f)</span></code></p></td>
<td><p>Returns the natural logarithm of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.exp(f)</span></code></p></td>
<td><p>Returns the exponential function of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.sqrt(f)</span></code></p></td>
<td><p>Returns the square root of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.sign(f)</span></code></p></td>
<td><p>Returns the sign(+1.0,-1.0) of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.abs(f)</span></code></p></td>
<td><p>Returns the absolute value an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="vector-norms-and-normalizations">
<h2>Vector Norms and Normalizations<a class="headerlink" href="#vector-norms-and-normalizations" title="Permalink to this headline">#</a></h2>
<p>For Vector Valued functions we also provide member functions that will compute various
useful norms and transformations on vectors. While most of these could be computed using the math operations
we have already covered, users should always use one of these methods if applicable, as the resulting expressions
will be much faster when evaluated. A few examples are illustrated here,
and a complete list of such functions is given in the table below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">r</span>   <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">r</span>   <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Same as above but slower</span>

<span class="n">v2</span> <span class="o">=</span>  <span class="n">V</span><span class="o">.</span><span class="n">squared_norm</span><span class="p">()</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># Same as above but slower</span>


<span class="n">Vhat</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">Vhat</span> <span class="o">=</span> <span class="n">V</span><span class="o">/</span><span class="n">V</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>        <span class="c1"># Same as above but slower</span>



<span class="n">r3</span> <span class="o">=</span>  <span class="n">R</span><span class="o">.</span><span class="n">cubed_norm</span><span class="p">()</span>

<span class="n">Grav</span> <span class="o">=</span> <span class="o">-</span> <span class="n">R</span><span class="o">.</span><span class="n">normalized_power3</span><span class="p">()</span>  <span class="c1"># R/|R|^3</span>
<span class="n">Grav2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">R</span><span class="o">/</span><span class="n">r3</span>         <span class="c1"># Same as above but slower</span>
</pre></div>
</div>
<div class="table-wrapper colwidths-given docutils container" id="id4">
<table class="colwidths-given docutils align-default" id="id4">
<caption><span class="caption-text">List of Vector Norms and Normalizations</span><a class="headerlink" href="#id4" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Math Form</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(|\vec{F}|\)</span></p></td>
<td><p>Returns the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.squared_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(|\vec{F}|^2\)</span></p></td>
<td><p>Returns the square of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.cubed_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(|\vec{F}|^3\)</span></p></td>
<td><p>Returns the cube of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.inverse_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(1/|\vec{F}|\)</span></p></td>
<td><p>Returns the inverse of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.inverse_squared_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(1/|\vec{F}|^2\)</span></p></td>
<td><p>Returns the inverse square of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.inverse_cubed_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(1/|\vec{F}|^3\)</span></p></td>
<td><p>Returns the inverse cube of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|}\)</span></p></td>
<td><p>Returns the normalized output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized_power2()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|^2}\)</span></p></td>
<td><p>Returns the output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code> divided by its euclidean norm squared.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized_power3()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|^3}\)</span></p></td>
<td><p>Returns the output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code> divided by its euclidean norm cubed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized_power4()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|^4}\)</span></p></td>
<td><p>Returns the output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code> divided by its euclidean norm to the fourth power.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized_power5()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|^5}\)</span></p></td>
<td><p>Returns the output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code> divided by its euclidean norm to the fifth power.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="vector-products">
<h2>Vector Products<a class="headerlink" href="#vector-products" title="Permalink to this headline">#</a></h2>
<p>In addition to the standard binary math operations supported via operator overloads,
we also provide member functions and free functions for performing various common vector operations.
The most commonly used are the dot, cross, quaternion, and coefficient-wise products,
A few examples of how these can be used are shown below. All functions appearing in these expressions must
have the correct output size, otherwise an error will be immediately thrown. You may also
mix and match constant numpy arrays and vector functions as needed to define your function. It should be noted
that our quaternion products assume that the vector part of the quaternion is the first three components of the output
while the real part is the 4th element(ie: q =[qv,q4])</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>

<span class="n">C2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>
<span class="n">C3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">])</span>
<span class="n">C4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">])</span>


<span class="n">dRV</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">dRV</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>

<span class="n">dRC</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>     <span class="c1"># use .dot with a constant vector of size 3</span>
<span class="n">dRC</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C3</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>  <span class="c1"># Or do it with a free function</span>

<span class="c1">#dRC = R.dot(C4)  # throws ERROR because vector is incorrect size</span>


<span class="n">RcrossV</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">RcrossV</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>
<span class="n">RcrossC3</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">C3</span><span class="p">)</span>

<span class="n">RcVcNdC3</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">))</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>

<span class="c1">#RcrossC4 = vf.cross(R,C4)  # throws an error</span>

<span class="n">KqpN</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">quatProduct</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">N</span><span class="p">)</span> <span class="c1"># Hamiltonian quaternion product</span>
<span class="n">Krn</span>  <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">quatRotate</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>  <span class="c1">## Rotates 3x1 vector V using quaternion K</span>



<span class="n">KpN</span>  <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cwiseProduct</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">NpC4</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">cwiseProduct</span><span class="p">(</span><span class="n">C4</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="stacking-outputs">
<h2>Stacking Outputs<a class="headerlink" href="#stacking-outputs" title="Permalink to this headline">#</a></h2>
<p>Up to this point, we have looked at partitioning and operating on the outputs
of other functions, and have not addressed how the outputs of functions may be combined together
into a larger single function. This can be accomplished using the VERY IMPORTANT <code class="code docutils literal notranslate"><span class="pre">vf.stack()</span></code> method.
In general stack takes a list of asset function types and produces another function whose output is the concatenation
of all the outputs. There are two signatures for stack, The first one (<code class="code docutils literal notranslate"><span class="pre">vf.stack([f1,f2,...])</span></code>) takes a python list
containing only explicit asset function types (ie: <code class="code docutils literal notranslate"><span class="pre">Element</span></code>, <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code> , <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code>, <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> etc..).
This version does not allow one to mix in floats or numpy vectors. The second signature (<code class="code docutils literal notranslate"><span class="pre">vf.stack(f1,f2,...)</span></code>) does the
same thing as the first but does not enclose the objects to be stacked inside of list. Additionally,
for this second signature, you may mix in arbitrary floats and numpy vectors that will be included in the output.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
          <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="n">Rhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">Nhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">That</span> <span class="o">=</span> <span class="n">Nhat</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Rhat</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>

<span class="n">RTN</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">Rhat</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">RTN</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [1. 0. 0. 0. 1. 0. 0. 0. 1.]</span>

<span class="c1">#Err = vf.stack([Rhat,That,np.array([1.0,1.0])]) # Throws Error, numpy array not allowed</span>

<span class="n">RTN</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">Rhat</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">)</span>  <span class="c1"># Same as above</span>

<span class="n">Stuff</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">Rhat</span><span class="p">,</span><span class="mf">42.0</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.71</span><span class="p">,</span><span class="mf">3.14</span><span class="p">])</span> <span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Stuff</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [ 7., 1., 0.,  0., 42., 0., 1., 0. ,0., 0. ,1. ,2.71,3.14]</span>
</pre></div>
</div>
</section>
<section id="matrix-operations">
<h2>Matrix Operations<a class="headerlink" href="#matrix-operations" title="Permalink to this headline">#</a></h2>
<p>While ASSET is and always will be a language for defining functions with vector valued
inputs and outputs, we do have limited but growing support for interpreting vector functions
as matrices inside of expressions. This is supported through the <code class="code docutils literal notranslate"><span class="pre">vf.ColMatrix</span></code> and <code class="code docutils literal notranslate"><span class="pre">vf.RowMatrix</span></code> types.
These are types constructed from some vector function and interprets the outputs as nxm matrix.
A <code class="code docutils literal notranslate"><span class="pre">ColMatrix</span></code> will interpret the coefficients of output as a column major matrix, whereas <code class="code docutils literal notranslate"><span class="pre">RowMatrix</span></code> interprets
them as a row major matrix. Once constructed you may multiply matrices by any other appropriately sized
Row/ColMatrix functions in any order, or multiply them on the right by appropriately sized VectorFunctions. The result
of all matrix on matrix operations are assumed to be <code class="code docutils literal notranslate"><span class="pre">ColMatrix</span></code> type. The result of Matrix*vector operations is <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code>.
Furthermore, square matrices may be inverted resulting in a Matrix type with same row/col type. For now one, may only add matrices
together if they have the same Row/Col type, though we will support this in the future.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="c1">## Three orthonormal basis vectors</span>
<span class="n">Rhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">Nhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">That</span> <span class="o">=</span> <span class="n">Nhat</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Rhat</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>

<span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">Rhat</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">])</span>

<span class="n">RTNmatC</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">ColMatrix</span><span class="p">(</span><span class="n">RTNcoeffs</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Interpret as col major 3x3 Rotation matrix</span>
<span class="n">RTNmatR</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">RowMatrix</span><span class="p">(</span><span class="n">RTNcoeffs</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Interpret as row major 3x3 Rotation matrix</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">RTNmatC</span><span class="o">*</span><span class="n">RTNmatR</span> <span class="c1"># Multiply matrices together result is column major</span>

<span class="n">U1</span> <span class="o">=</span> <span class="n">RTNmatC</span><span class="o">*</span><span class="n">U</span>       <span class="c1"># Multiply on the right by a VectorFunction of size (3x1)</span>
<span class="n">U2</span> <span class="o">=</span> <span class="n">RTNmatR</span><span class="o">*</span><span class="n">U</span>
<span class="n">U3</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">U</span>

<span class="n">ZERO</span> <span class="o">=</span> <span class="n">RTNmatR</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">*</span><span class="n">U</span> <span class="o">-</span><span class="n">RTNmatC</span><span class="o">*</span><span class="n">U</span>


<span class="n">RTNmatC</span> <span class="o">+</span><span class="n">RTNmatC</span>
</pre></div>
</div>
</section>
<section id="conditional-statement-operations">
<h2>Conditional Statement/Operations<a class="headerlink" href="#conditional-statement-operations" title="Permalink to this headline">#</a></h2>
<p>Asset’s intended use case is for defining constraint,objectives, and dynamical
models that will eventually be put to use inside of a second derivative optimizer. As a
general rule of thumb, it is a bad idea for such functions to contain conditional statements,
as this could potentially result non-smooth derivatives. In these cases we always recommend considering
whether what you were trying to accomplish with the conditional statement can be reformulated in another way.
However if this is not possible, or you are writing a function that will not see the inside of an optimizer,
we do offer support for simple conditional statements and boolean operations with vector function expressions.
To be precise,we support constructing boolean statements involving the outputs of scalar valued functions, and then
using those as conditional statements to control the output of another expression. Conditional statements are constructed by
applying the comparison operators (&gt;,&lt;,&lt;=,&gt;=) to the outputs of scalar functions. This can be used to dispatch one of
two functions using the <code class="code docutils literal notranslate"><span class="pre">vf.ifelse()</span></code> function as shown below. Note that the output sizes of both the true and false functions
MUST be the same. Conditional statements may also be combined together using the bitwise or and operators (<a href="#id1"><span class="problematic" id="id2">|</span></a>,&amp;).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="n">condition</span> <span class="o">=</span> <span class="n">x0</span><span class="o">&lt;</span><span class="mf">1.0</span>

<span class="n">output_if_true</span> <span class="o">=</span> <span class="n">x1</span><span class="o">*</span><span class="mi">2</span>
<span class="n">output_if_false</span> <span class="o">=</span> <span class="n">x1</span><span class="o">+</span><span class="n">x2</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="n">output_if_true</span><span class="p">,</span><span class="n">output_if_false</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [4.0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [5.0]</span>


<span class="n">Fine</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">),</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">x1</span><span class="p">))</span>
<span class="c1">#Error = vf.ifelse(condition,vf.stack(x1,x2),output_if_false)</span>


<span class="n">combo_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span><span class="o">&lt;</span><span class="mf">1.0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">x0</span><span class="o">&gt;</span><span class="n">x1</span><span class="p">)</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">ifelse</span><span class="p">(</span><span class="n">combo_condition</span><span class="p">,</span><span class="n">output_if_true</span><span class="p">,</span><span class="n">output_if_false</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [4.0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [5.0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mf">2.5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [4.0]</span>
</pre></div>
</div>
</section>
<section id="some-notes-on-input-arguments">
<h2>Some Notes on Input Arguments<a class="headerlink" href="#some-notes-on-input-arguments" title="Permalink to this headline">#</a></h2>
<p>Before, moving on any further, we need to make one very important note about how the vector
function type system works. In all of our previous examples, we have created and partitioned
one set of arguments of a certain size, from which we constructed other functions. You might
ask, what happens if we try to mix expressions formulated out of arguments of different sizes.
This is strictly not allowed, as our entire type system predicated on the fact that expressions can
only be combined if they have the same sized input arguments. For example, the following code will
throw an error to alert you that you have made a mistake. However, we should also note as shown below,
that there is nothing unique about any two sets of arguments of the same size. Thus you may (though it is pointless)
combine expressions derived from two arguments objects of the same size.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X1</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">X2</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">X3</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="n">R1</span><span class="p">,</span><span class="n">V1</span><span class="p">,</span><span class="n">U1</span> <span class="o">=</span> <span class="n">X1</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="n">R2</span><span class="p">,</span><span class="n">V2</span><span class="p">,</span><span class="n">U2</span> <span class="o">=</span> <span class="n">X2</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="n">R3</span><span class="p">,</span><span class="n">V3</span><span class="p">,</span><span class="n">U3</span> <span class="o">=</span> <span class="n">X3</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="c1">#Error = R1 + R2</span>
<span class="c1">#Error = R1.dot(V2)</span>

<span class="c1">## These two functions do identical things</span>
<span class="n">Fine</span> <span class="o">=</span> <span class="n">R2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V3</span><span class="p">)</span>
<span class="n">Fine</span> <span class="o">=</span> <span class="n">R3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="suggested-style-and-organization">
<h2>Suggested Style and Organization<a class="headerlink" href="#suggested-style-and-organization" title="Permalink to this headline">#</a></h2>
<p>At this point we have covered most all of the operations one can and cant perform with asset
vector functions, with the important exception of function composition
(which we will cover in the next section). As you might have noticed, in all of
our scratch pad examples, we simply created a single set of arguments and operated on them
in the same scope. Everyone of these functions is a fully formed asset type and can be immediately passed
off to other parts of the library to be used as constraints/ODEs/controllers etc. However, obviously it is not a recipe
for longterm success to simply write expressions inline wherever they are needed. How you package or
encapsulate the construction of asset vector-functions is up to you, but we suggest one of the following two methods.</p>
<p>Method one involves simply writing a standard python function that takes as arguments
any meta data or constants, needed to define the function, then writing and returning your asset
vector function. A trivial example of this is shown below, and you can find many others throughout our
problem specific examples contained in other sections.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">FuncMeth</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
        <span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">eq1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span><span class="n">a</span> <span class="o">-</span> <span class="n">x1</span>
        <span class="n">eq2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">x1</span><span class="o">*</span><span class="n">c</span>
        <span class="k">return</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span><span class="n">eq2</span><span class="p">)</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">FuncMeth</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># prints [1,5]</span>
</pre></div>
</div>
<p>Method two involves defining a new class that inherits from the appropriate
ASSET type (<code class="code docutils literal notranslate"><span class="pre">vf.VectorFunction</span></code> if output size is &gt;1, <code class="code docutils literal notranslate"><span class="pre">vf.ScalarFunction</span></code> of output size =1)
and then defining and initializing the expression in the constructor. This method should only
be preferred if you need to store the meta-data as part of the class
or add additional methods to the object. Otherwise, this method is functionally identical to
the one above.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FuncClass</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">VectorFunction</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span><span class="n">a</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span><span class="n">b</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span><span class="n">c</span>

                <span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">eq1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span><span class="n">a</span> <span class="o">-</span> <span class="n">x1</span>
                <span class="n">eq2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">x1</span><span class="o">*</span><span class="n">c</span>

                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span><span class="n">eq2</span><span class="p">))</span> <span class="c1">#Do not forget to call CTOR of Base!!</span>

        <span class="k">def</span> <span class="nf">get_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">FuncClass</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># prints [1,5]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">get_a</span><span class="p">())</span>   <span class="c1"># prints 1</span>
</pre></div>
</div>
</section>
<section id="calling-existing-asset-functions-inside-other-functions">
<h2>Calling Existing Asset Functions inside other functions<a class="headerlink" href="#calling-existing-asset-functions-inside-other-functions" title="Permalink to this headline">#</a></h2>
<p>Now that we have a good understanding of the rules and style for defining
single vector-functions, we can cover how to call them inside of other functions.
For this final example let us tackle a concrete problem that occurs
in astrodynamics: frame conversions. Specifically, we wish to write a function that takes
the position and velocity of some object in Cartesian coordinates, as well as some other vector,
and then transforms that vector into the RTN frame. The RTN basis vectors can be computed purely as a function
of position and velocity, so let us first write a function that does just that.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RTNBasis</span><span class="p">():</span>

        <span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

        <span class="n">Rhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
        <span class="n">Nhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
        <span class="n">That</span> <span class="o">=</span> <span class="n">Nhat</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">Rhat</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then write another function that takes position and velocity as well as the vector
to be transformed. We then instantiate our previously defined function that
computes basis vectors and then “call” it with the position and velocity arguments
defined inside our new function. Calling the already instantiated function, can be accomplished
using the providing a correctly sized function to the <code class="code docutils literal notranslate"><span class="pre">()</span></code> call operator the same way we do for
real number arguments. In this case, providing the contiguous segment of size 6 <code class="code docutils literal notranslate"><span class="pre">RV</span></code>, is the most efficient
way to the define the expression. However, if this were not the case, we could also the other
call signatures shown. We can provide two separate functions, in this case <code class="code docutils literal notranslate"><span class="pre">R</span></code> and <code class="code docutils literal notranslate"><span class="pre">V</span></code>
either as individual arguments or grouped together in a python list. These will be implicitly
stacked using the same rules governing <code class="code docutils literal notranslate"><span class="pre">vf.stack</span></code> and then forwarded to the function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RTNTransform</span><span class="p">():</span>


        <span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>

        <span class="n">RV</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

        <span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

        <span class="n">RTNBasisFunc</span> <span class="o">=</span> <span class="n">RTNBasis</span><span class="p">()</span> <span class="c1"># Instantiate function object</span>


        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">(</span><span class="n">RV</span><span class="p">)</span>  <span class="c1">### Call Function at new vectorfunction arguments</span>

        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">)</span> <span class="c1"># Same effect as original but slower</span>
        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">))</span> <span class="c1"># Does Exactly the same thing as above calls stack on R,V explicitly</span>

        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">])</span> <span class="c1"># Same effect as original but slower</span>
        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">]))</span> <span class="c1"># Does Exactly the same thing as above calls stack on [R,V] explicitly</span>



        <span class="n">RTNmat</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">RowMatrix</span><span class="p">(</span><span class="n">RTNcoeffs</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">U_RTN</span> <span class="o">=</span> <span class="n">RTNmat</span><span class="o">*</span><span class="n">U</span>

        <span class="k">return</span> <span class="n">U_RTN</span>
</pre></div>
</div>
</section>
<section id="repeated-sub-expressions">
<h2>Repeated Sub Expressions<a class="headerlink" href="#repeated-sub-expressions" title="Permalink to this headline">#</a></h2>
<p>Being a functional programming language, it is important to note that an asset
expression is evaluated every where it appears in a statement. There is no notion
of assigning it to a temporary variable and then reusing it later without recalculating it.
For example,in the following code, just because we bind the complicated expression to
the name <code class="code docutils literal notranslate"><span class="pre">expensive</span></code>, the function <code class="code docutils literal notranslate"><span class="pre">answer</span></code> will still require actually
evaluating <code class="code docutils literal notranslate"><span class="pre">expensive</span></code> three times.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="n">expensive</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">normalized_power3</span><span class="p">())</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="n">V</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()))</span><span class="o">**</span><span class="mf">3.14</span>

<span class="n">answer</span> <span class="o">=</span> <span class="n">R</span><span class="o">+</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">expensive</span><span class="p">,</span><span class="n">expensive</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">expensive</span><span class="p">)</span>
</pre></div>
</div>
<p>In the vast majority of cases you should not worry about the cost of reevaluating subexpressions,
as the run time hit is marginal. There is however, one way to explicitly ensure to reduce the cost of expensive repeated
sub expressions should you need to. You can do this by writing a second function where the subexpression appears
linearly as additional arguments or segments and then using the call operator to compose this new function
and the original arguments and subexpression together. For example, the following code will produce the same output
as above while only ever evaluating <code class="code docutils literal notranslate"><span class="pre">expensive</span></code> once.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="n">expensive</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">normalized_power3</span><span class="p">())</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="n">V</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()))</span><span class="o">**</span><span class="mf">3.14</span>


<span class="c1">## New args for defining function of only R and expensive</span>
<span class="n">R_temp</span><span class="p">,</span> <span class="n">expensive_tmp</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>

<span class="n">answer_tmp</span> <span class="o">=</span> <span class="n">R_temp</span><span class="o">+</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">expensive_tmp</span><span class="p">,</span><span class="n">expensive_tmp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">expensive_tmp</span><span class="p">)</span>

<span class="n">answer</span> <span class="o">=</span> <span class="n">answer_tmp</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">expensive</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="note-on-size-of-vectorfunctions">
<h2>Note on Size of VectorFunctions<a class="headerlink" href="#note-on-size-of-vectorfunctions" title="Permalink to this headline">#</a></h2>
<p>The vector-function type system has been designed to have good performance for evaluating
the value and derivatives of dense vector functions with a small number of arguments (&lt;50).
It will work for larger expressions, but performance will begin to degrade considerably. This may seem
strange since it ostensibly designed to be used to define constraints and objective inside of large
sparse non-linear programs. However, in our experience these problems are almost never composed
of single monolithic functions, and can generally be decomposed into smaller dense functions that only
take a partial subsets of the problem variables. In that case we can define our functions in terms of
only the arguments they take, and then under the hood, asset will ensure that the inputs and outputs are gathered and
scattered to the correct locations inside the larger problem. The specifics of how this works will be handled in later
sections.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># Legal but Bad</span>
</pre></div>
</div>
</section>
<section id="tabular-data-and-interpolation">
<h2>Tabular Data and Interpolation<a class="headerlink" href="#tabular-data-and-interpolation" title="Permalink to this headline">#</a></h2>
</section>
<section id="binding-raw-python-functions">
<h2>Binding Raw Python Functions<a class="headerlink" href="#binding-raw-python-functions" title="Permalink to this headline">#</a></h2>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="ODEGuide.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">ODE Tutorial</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="Installation.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Python: Installing ASSET</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021, UA ASRL
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Vector Function Tutorial</a><ul>
<li><a class="reference internal" href="#arguments">Arguments</a></li>
<li><a class="reference internal" href="#standard-math-operations">Standard Math Operations</a></li>
<li><a class="reference internal" href="#scalar-math-operations">Scalar Math Operations</a></li>
<li><a class="reference internal" href="#vector-norms-and-normalizations">Vector Norms and Normalizations</a></li>
<li><a class="reference internal" href="#vector-products">Vector Products</a></li>
<li><a class="reference internal" href="#stacking-outputs">Stacking Outputs</a></li>
<li><a class="reference internal" href="#matrix-operations">Matrix Operations</a></li>
<li><a class="reference internal" href="#conditional-statement-operations">Conditional Statement/Operations</a></li>
<li><a class="reference internal" href="#some-notes-on-input-arguments">Some Notes on Input Arguments</a></li>
<li><a class="reference internal" href="#suggested-style-and-organization">Suggested Style and Organization</a></li>
<li><a class="reference internal" href="#calling-existing-asset-functions-inside-other-functions">Calling Existing Asset Functions inside other functions</a></li>
<li><a class="reference internal" href="#repeated-sub-expressions">Repeated Sub Expressions</a></li>
<li><a class="reference internal" href="#note-on-size-of-vectorfunctions">Note on Size of VectorFunctions</a></li>
<li><a class="reference internal" href="#tabular-data-and-interpolation">Tabular Data and Interpolation</a></li>
<li><a class="reference internal" href="#binding-raw-python-functions">Binding Raw Python Functions</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>