<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="ODE Tutorial" href="ODEGuide.html" /><link rel="prev" title="Installing ASSET" href="Install.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.01.29 -->
        <title>Vector Function Tutorial - ASSET 0.3.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: red;
  --color-brand-content: #CC3333;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ASSET 0.3.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/ASSETLOGO.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ASSET 0.3.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="tutorials.html">Tutorials</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Install.html">Installing ASSET</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Vector Function Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ODEGuide.html">ODE Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="IntegratorGuide.html">Integrator Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="PhaseGuide.html">Optimal Control Phase Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptimalControlProblem.html">Optimal Control Problem Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="PSIOPT.html">PSIOPT</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutoMeshGuide.html">Adaptive Mesh Refinement Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptimalControlUtilites.html">Optimal Control Utilities</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../examples/examples.html">Examples</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Examples</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples/Delta3.html">Delta 3 Multi-phase GTO Transfer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ReentryExample.html">Space Shuttle Reentry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/CartPole.html">Cart-Pole Swing Up</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/HyperSensitive.html">Hyper-Sensitive Optimal Control Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/halo.html">Orbit Family Continuation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/zermelo.html">Zermelo’s Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/zermelolink.html">Multi-Phase Zermelo’s Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/MultiTarg.html">Multi-Spacecraft Optimization</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../python/python.html">Python Library Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Python Library Documentation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../python/asset.html">ASSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/optimalcontrol.html">Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/vectorfunctions.html">Vector Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/Astro.html">ASSET Astro Library</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="vector-function-tutorial">
<span id="vectorfunction-guide"></span><h1>Vector Function Tutorial<a class="headerlink" href="#vector-function-tutorial" title="Link to this heading">#</a></h1>
<p>One of the goals of ASSET is to provide users the ability to construct functions
dynamically within Python that are able to be used by ASSET. By doing this we can simplify a user’s work-flow,
where the benefits of high speed C++ code can be combined with the ease of use Python provides.
In this section we will give an depth overview of ASSET’s VectorFunction type. At a high-level,
this is simple functional (in the programming sense) domain specific language for defining
mathematical Vector Functions that take a fixed number of inputs
and produce a fixed number outputs, with both inputs and outputs assumed to be column vectors.</p>
<section id="arguments">
<h2>Arguments<a class="headerlink" href="#arguments" title="Link to this heading">#</a></h2>
<p>Let us begin by importing ASSET and the VectorFunctions module which contains all types
and functions defining the language. From this module, we will then import the Arguments type
and give it a shorthand name. The <code class="code docutils literal notranslate"><span class="pre">Arguments</span></code> type is the base expression in the VectorFunction system
and represents a function that simply takes some number of input arguments and returns them as outputs.
It always serves as the starting point for defining more complicated functional expressions involving
some or all of its outputs.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">vf</span>        <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">VectorFunctions</span>
<span class="n">Args</span>      <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">Arguments</span>
</pre></div>
</div>
<p>We can construct the object by simply specifying the number of arguments, which in this case is 6. This instance <code class="code docutils literal notranslate"><span class="pre">X</span></code> is now a first class function thats takes any vector of size 6
and returns that vector. Since it is a VectorFunction, we can compute its output value using the
<code class="code docutils literal notranslate"><span class="pre">()</span></code> operator, first derivative using the <code class="code docutils literal notranslate"><span class="pre">.jacobian</span></code> method, and second derivative using the <code class="code docutils literal notranslate"><span class="pre">.adjointhessian</span></code> method.
To do this, we provide either a numpy vector or python list of real valued inputs, and additionally for the second derivative,
a vector list of lagrange multipliers with same dimensions as the output of the function. One important note, ASSET does not compute
the full 3D tensor second derivative of vector valued functions, instead it computes the second derivative
dotted with a vector lagrange multipliers, resulting in a 2D symmetric matrix with rows and columns equal to the number of inputs.
We refer to this as the adjointhessian, and in the case of a function with a single output it is equivalent to the normal hessian.
Since <code class="code docutils literal notranslate"><span class="pre">X</span></code> here is a simple linear function, the first derivative is simply the identity matrix and the adjointhessian is zero. This is
a rather trivial example, but the same methods can be applied to any ASSET VectorFunction that we can construct. We should also note that while
these methods are available for all VectorFunctions, for most applications and examples you won’t ever actually need to explicitly
call the function or its derivatives at real arguments, as that will be handled for you by some other interface such as an integrator or optimal
control problem.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="n">lvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">6</span><span class="p">))</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span> <span class="n">X</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#prints [0,1,2,3,4,5]</span>

<span class="nb">print</span><span class="p">(</span> <span class="n">X</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#prints Identiy matrix of size 6</span>

<span class="nb">print</span><span class="p">(</span> <span class="n">X</span><span class="o">.</span><span class="n">adjointhessian</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span><span class="n">lvals</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#prints zero matrix of size 6</span>
</pre></div>
</div>
<p>As you can see, <code class="code docutils literal notranslate"><span class="pre">Arguments</span></code> itself does not do anything very interesting, but what it does do is
serve as a starting point for defining functions of elements and sub-vectors. For example, we may
make a new object referencing one of its elements by using the bracket operator. This will return an object of
another fundamental type, <code class="code docutils literal notranslate"><span class="pre">Element</span></code>, which is itself a function that takes all input arguments and returns the specified
element as a scalar output. Attempting to address an element out of bounds of the <code class="code docutils literal notranslate"><span class="pre">Arguments</span></code> will immediately throw an
error at the offending operation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">x0</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">x5</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">#x42 =X[42]  #throws an error</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1"># prints [0.0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x5</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1"># prints [5.0]</span>
</pre></div>
</div>
<p>Often times you will write an expression where the Arguments represent many separate
distinct scalar elements that will be combined to construct a more complicated expression.
In this case, we can bypass the many lines necessary to index them individually, by using
the <code class="code docutils literal notranslate"><span class="pre">.tolist()</span></code> method of Arguments. This method will return all the individual elements concatenated
in order inside of a single python list, which we can then unpack into individual named elements in a single line.
You may use whatever method you wish, but we personally prefer the <code class="code docutils literal notranslate"><span class="pre">.tolist()</span></code> method in this case.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">x0</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">x4</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">x5</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">## Equivalent to</span>

<span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">,</span><span class="n">x5</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>
</div>
<p>In addition to scalar Elements, one may also address contiguous sub-vectors in a set of arguments
using the <code class="code docutils literal notranslate"><span class="pre">.head()</span></code>, <code class="code docutils literal notranslate"><span class="pre">.tail()</span></code>, and <code class="code docutils literal notranslate"><span class="pre">.segment()</span></code> methods of <code class="code docutils literal notranslate"><span class="pre">Arguments</span></code>, or standard python (contiguous) list indexing.
For example, if we want to treat the first three arguments of the Arguments below as a single vector <code class="code docutils literal notranslate"><span class="pre">R</span></code>, we can
use the <code class="code docutils literal notranslate"><span class="pre">.head(n)</span></code> method. The <code class="code docutils literal notranslate"><span class="pre">.head(n)</span></code> method returns a sub-vector of size <code class="code docutils literal notranslate"><span class="pre">n</span></code> starting at the first element. This syntax mirrors the
Eigen C++ library, which we find to be quite nice, but you may also use standard python list indexing to accomplish the same
goal. Similarly, if we want to address the last three arguments as a single vector <code class="code docutils literal notranslate"><span class="pre">V</span></code> , we can use the <code class="code docutils literal notranslate"><span class="pre">.tail(n)</span></code> method which returns
the last <code class="code docutils literal notranslate"><span class="pre">n</span></code> elements of some arguments. Finally, we can address vectors of length <span class="math notranslate nohighlight">\(n\)</span> starting at index <code class="code docutils literal notranslate"><span class="pre">i</span></code>
using the <code class="code docutils literal notranslate"><span class="pre">.segment(i,n)</span></code> method. The return type of all of these methods is the fundamental <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> type, which is a function that returns
as its output the specified sub-vector of the arguments.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>    <span class="c1"># Same as above</span>

<span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span> <span class="c1">#prints [1,2,3]</span>


<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>    <span class="c1"># same as above</span>

<span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [4,5,6]</span>


<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># same as R above</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># same as V above</span>


<span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># first argument is starting index, second is size</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>         <span class="c1">#same as above but python style</span>

<span class="nb">print</span><span class="p">(</span><span class="n">N</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>    <span class="c1"># prints [2,3,4,5]</span>
</pre></div>
</div>
<p>Paralleling what we did before with elements, we can also partition an input argument list
list into segments and elements using the <code class="code docutils literal notranslate"><span class="pre">.tolist([(start,size),</span> <span class="pre">..])</span></code> method. In this case, we should
pass a python list of tuples, where the first element of each tuple is the starting index of the sub-vector
and the second is the size; sub-vectors of size one are returned as elements. Note that this method does not
require you to partition all of the argument set, though this example does. Furthermore, it is not
required that the sub-vectors specified be in any particular order, though we highly recommend you sort them
according to starting index.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>

<span class="c1">## Equivalent to the Above</span>
<span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">u</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">])</span>



<span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span> <span class="c1">#prints [1,2,3]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [4,5,6]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [7]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [8]</span>
</pre></div>
</div>
<p>Finally, all of the above indexing methods behave exactly the same when applied
to segments rather than arguments, and we can address their individual components
as elements, and split them in smaller segments. For example, we may split <code class="code docutils literal notranslate"><span class="pre">R</span></code> into
its scalar components using <code class="code docutils literal notranslate"><span class="pre">.tolist</span></code>, address a single component using brackets, or a subsegment
using head, tail, segment, etc..</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">r0</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">r0</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints([1])</span>

<span class="n">v0</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">v0</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints([4])</span>

<span class="n">V12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">V12</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints([5,6])</span>
</pre></div>
</div>
</section>
<section id="standard-math-operations">
<h2>Standard Math Operations<a class="headerlink" href="#standard-math-operations" title="Link to this heading">#</a></h2>
<p>Having covered most everything related to constructing arguments, and their elements
and sub-vectors, we can move on the to combining them together into meaningful mathematical functions.
We should note that the result of any mathematical non-indexing operation will have
the generic type <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> (more than one output) or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code> (one output),
which themselves may be operated on and combined with the three
fundamental types using the same rules. In general, types will be converted automatically, and
users should not concern themselves with the types of resulting expressions
and should only make sure that their expressions are mathematically consistent.
We may add, subtract, multiply, and divide functions by other functions and numerical constants using
the standard rules of vector math. For example,
we may add or subtract two functions of the same output size to together, add or subtract vectors
of constants or constant scalars, multiply functions by constant scalars, multiply functions by Scalar functions, etc.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">5.0</span>

<span class="n">RpV</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="n">V</span>

<span class="n">RmC</span> <span class="o">=</span> <span class="n">R</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>

<span class="n">Rtv0</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">RtC</span>   <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="mi">2</span>

<span class="n">RdC</span>   <span class="o">=</span> <span class="n">R</span><span class="o">/</span><span class="mi">2</span>

<span class="n">Vdr0</span> <span class="o">=</span> <span class="n">V</span><span class="o">/</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">N</span> <span class="o">=</span> <span class="n">Rtv0</span> <span class="o">+</span> <span class="n">RdC</span>

<span class="n">v1pv0</span> <span class="o">=</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">9.0</span><span class="p">)</span><span class="o">*</span><span class="mf">2.0</span>

<span class="n">inv0</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">v0</span>
</pre></div>
</div>
<p>As this is a vector math language, certain operations involving vectors are not
allowed via standard multiply and divide operator overloads. For example, one may
not multiply two VectorFunctions together using the * operator as is possible with two arrays in numpy.
This is an explicit choice because in our opinion, for the types of expressions written using ASSET,
allowing element-wise vector multiplication creates more problems in terms of incorrect problem formulation than it solves.
However, these operations can be accomplished using methods we describe later. Note,
this does not apply to ScalarFunctions such as <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code>, which may be multiplied together with
no issue, and may also scale a VectorFunction.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">## RmV = R*V  # Throws and Error</span>
<span class="c1">## RdV = R/V  # Throws and Error</span>
</pre></div>
</div>
</section>
<section id="scalar-math-operations">
<h2>Scalar Math Operations<a class="headerlink" href="#scalar-math-operations" title="Link to this heading">#</a></h2>
<p>Next, we will move on to describe the standard mathematical functions that can be applied to scalar
valued functions. These encompass most of the standard functions that can be found in python or C math libraries,
such as sin, cos, tan, etc. All of these functions are stored inside the VectorFunctions module (which we have imported as <code class="code docutils literal notranslate"><span class="pre">vf</span></code>),
and can be called as shown below. A complete list of functions is given in the table below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">cosh</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">3.14</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># power operator</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">h</span>  <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="table-wrapper colwidths-given docutils container" id="id6">
<table class="docutils align-default" id="id6">
<caption><span class="caption-text">List of Scalar Math Functions</span><a class="headerlink" href="#id6" title="Link to this table">#</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.sin(f)</span></code></p></td>
<td><p>Returns the sine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.cos(f)</span></code></p></td>
<td><p>Returns the cosine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.tan(f)</span></code></p></td>
<td><p>Returns the tangent of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arcsin(f)</span></code></p></td>
<td><p>Returns the inverse sine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arccos(f)</span></code></p></td>
<td><p>Returns the inverse cosine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arctan(f)</span></code></p></td>
<td><p>Returns the inverse tangent of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.sinh(f)</span></code></p></td>
<td><p>Returns the hyperbolic sine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.cosh(f)</span></code></p></td>
<td><p>Returns the hyperbolic cosine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.tanh(f)</span></code></p></td>
<td><p>Returns the hyperbolic tangent of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arcsinh(f)</span></code></p></td>
<td><p>Returns the inverse  hyperbolic sine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arccosh(f)</span></code></p></td>
<td><p>Returns the inverse  hyperbolic cosine of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.arctanh(f)</span></code></p></td>
<td><p>Returns the inverse  hyperbolic tangent of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.log(f)</span></code></p></td>
<td><p>Returns the natural logarithm of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.exp(f)</span></code></p></td>
<td><p>Returns the exponential function of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.sqrt(f)</span></code></p></td>
<td><p>Returns the square root of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.sign(f)</span></code></p></td>
<td><p>Returns the sign(+1.0,-1.0) of an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">vf.abs(f)</span></code></p></td>
<td><p>Returns the absolute value an input <code class="code docutils literal notranslate"><span class="pre">Element</span></code> or <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="vector-norms-and-normalizations">
<h2>Vector Norms and Normalizations<a class="headerlink" href="#vector-norms-and-normalizations" title="Link to this heading">#</a></h2>
<p>For Vector valued functions, we also provide member functions that will compute various
useful norms and transformations on vectors. While most of these could be computed using the math operations
we have already covered, users should always use one of these methods if applicable, as the resulting expressions
will be much faster when evaluated. A few examples are illustrated here,
and a complete list of such functions is given in the table below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">r</span>   <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">r</span>   <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Same as above but slower</span>

<span class="n">v2</span> <span class="o">=</span>  <span class="n">V</span><span class="o">.</span><span class="n">squared_norm</span><span class="p">()</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># Same as above but slower</span>


<span class="n">Vhat</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">Vhat</span> <span class="o">=</span> <span class="n">V</span><span class="o">/</span><span class="n">V</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>        <span class="c1"># Same as above but slower</span>



<span class="n">r3</span> <span class="o">=</span>  <span class="n">R</span><span class="o">.</span><span class="n">cubed_norm</span><span class="p">()</span>

<span class="n">Grav</span> <span class="o">=</span> <span class="o">-</span> <span class="n">R</span><span class="o">.</span><span class="n">normalized_power3</span><span class="p">()</span>  <span class="c1"># R/|R|^3</span>
<span class="n">Grav2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">R</span><span class="o">/</span><span class="n">r3</span>         <span class="c1"># Same as above but slower</span>
</pre></div>
</div>
<div class="table-wrapper colwidths-given docutils container" id="id7">
<table class="docutils align-default" id="id7">
<caption><span class="caption-text">List of Vector Norms and Normalizations</span><a class="headerlink" href="#id7" title="Link to this table">#</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Math Form</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(|\vec{F}|\)</span></p></td>
<td><p>Returns the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.squared_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(|\vec{F}|^2\)</span></p></td>
<td><p>Returns the square of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.cubed_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(|\vec{F}|^3\)</span></p></td>
<td><p>Returns the cube of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.inverse_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(1/|\vec{F}|\)</span></p></td>
<td><p>Returns the inverse of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.inverse_squared_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(1/|\vec{F}|^2\)</span></p></td>
<td><p>Returns the inverse square of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.inverse_cubed_norm()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(1/|\vec{F}|^3\)</span></p></td>
<td><p>Returns the inverse cube of the euclidean norm of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|}\)</span></p></td>
<td><p>Returns the normalized output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized_power2()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|^2}\)</span></p></td>
<td><p>Returns the output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code> divided by its euclidean norm squared.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized_power3()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|^3}\)</span></p></td>
<td><p>Returns the output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code> divided by its euclidean norm cubed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized_power4()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|^4}\)</span></p></td>
<td><p>Returns the output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code> divided by its euclidean norm to the fourth power.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">F.normalized_power5()</span></code></p></td>
<td><p><span class="math notranslate nohighlight">\(\frac{\vec{F}}{|\vec{F}|^5}\)</span></p></td>
<td><p>Returns the output of <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> <code class="code docutils literal notranslate"><span class="pre">F</span></code> divided by its euclidean norm to the fifth power.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="vector-products">
<h2>Vector Products<a class="headerlink" href="#vector-products" title="Link to this heading">#</a></h2>
<p>In addition to the standard binary math operations supported via operator overloads,
we also provide member functions and free functions for performing various common vector operations.
The most commonly used are the dot, cross, quaternion, and coefficient-wise products.
A few examples of how these can be used are shown below. All functions appearing in these expressions must
have the correct output size, otherwise an error will be immediately thrown. You may also
mix and match constant numpy arrays and VectorFunctions as needed to define your function. It should be noted
that our quaternion products assume that the vector part of the quaternion is the first three components of the output
while the real part is the 4th element(ie: q =[qv,q4]).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>

<span class="n">C2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>
<span class="n">C3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">])</span>
<span class="n">C4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">])</span>


<span class="n">dRV</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">dRV</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>

<span class="n">dRC</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>     <span class="c1"># use .dot with a constant vector of size 3</span>
<span class="n">dRC</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C3</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>  <span class="c1"># Or do it with a free function</span>

<span class="c1">#dRC = R.dot(C4)  # throws ERROR because vector is incorrect size</span>


<span class="n">RcrossV</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">RcrossV</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>
<span class="n">RcrossC3</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">C3</span><span class="p">)</span>

<span class="n">RcVcNdC3</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">))</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>

<span class="c1">#RcrossC4 = vf.cross(R,C4)  # throws an error</span>

<span class="n">KqpN</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">quatProduct</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">N</span><span class="p">)</span> <span class="c1"># Hamiltonian quaternion product</span>
<span class="n">Krn</span>  <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">quatRotate</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>  <span class="c1">## Rotates 3x1 vector V using quaternion K</span>


<span class="n">KpN</span>  <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cwiseProduct</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">NpC4</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">cwiseProduct</span><span class="p">(</span><span class="n">C4</span><span class="p">)</span>
<span class="n">KdN</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cwiseQuotient</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="stacking-outputs">
<h2>Stacking Outputs<a class="headerlink" href="#stacking-outputs" title="Link to this heading">#</a></h2>
<p>Up to this point, we have looked at partitioning and operating on the outputs
of other functions, and have not addressed how the outputs of functions may be combined together
into a larger single function. This can be accomplished using the <strong>VERY IMPORTANT</strong> <code class="code docutils literal notranslate"><span class="pre">vf.stack()</span></code> method.
In general stack takes a list of ASSET function types and produces another function whose output is the concatenation
of all the outputs. There are two signatures for stack, The first one (<code class="code docutils literal notranslate"><span class="pre">vf.stack([f1,f2,...])</span></code>) takes a python list
containing only explicit ASSET function types (ie: <code class="code docutils literal notranslate"><span class="pre">Element</span></code>, <code class="code docutils literal notranslate"><span class="pre">ScalarFunction</span></code> , <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code>, <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> etc..).
This version does not allow one to mix in floats or numpy vectors. The second signature (<code class="code docutils literal notranslate"><span class="pre">vf.stack(f1,f2,...)</span></code>) does the
same thing as the first but does not enclose the objects to be stacked inside of a list. Additionally,
for this second signature, you may mix in arbitrary floats and numpy vectors that will be included in the output.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
          <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="n">Rhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">Nhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">That</span> <span class="o">=</span> <span class="n">Nhat</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Rhat</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>

<span class="n">RTN</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">Rhat</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">RTN</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [1. 0. 0. 0. 1. 0. 0. 0. 1.]</span>

<span class="c1">#Err = vf.stack([Rhat,That,np.array([1.0,1.0])]) # Throws Error, numpy array not allowed</span>

<span class="n">RTN</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">Rhat</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">)</span>  <span class="c1"># Same as above</span>

<span class="n">Stuff</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">Rhat</span><span class="p">,</span><span class="mf">42.0</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.71</span><span class="p">,</span><span class="mf">3.14</span><span class="p">])</span> <span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Stuff</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>  <span class="c1">#prints [ 7., 1., 0.,  0., 42., 0., 1., 0. ,0., 0. ,1. ,2.71,3.14]</span>
</pre></div>
</div>
</section>
<section id="matrix-operations">
<h2>Matrix Operations<a class="headerlink" href="#matrix-operations" title="Link to this heading">#</a></h2>
<p>While ASSET is and always will be a language for defining functions with vector valued
inputs and outputs, we do have limited but growing support for interpreting VectorFunctions
as matrices inside of expressions. This is supported through the <code class="code docutils literal notranslate"><span class="pre">vf.ColMatrix</span></code> and <code class="code docutils literal notranslate"><span class="pre">vf.RowMatrix</span></code> types.
These are types constructed from some VectorFunction and interprets the outputs as <span class="math notranslate nohighlight">\(n \times m\)</span> matrix.
A <code class="code docutils literal notranslate"><span class="pre">ColMatrix</span></code> will interpret the coefficients of the output as a column major matrix, whereas <code class="code docutils literal notranslate"><span class="pre">RowMatrix</span></code> interprets
them as a row major matrix. Once constructed you may multiply matrices by any other appropriately sized
Row/ColMatrix functions in any order, or multiply them on the right by appropriately sized VectorFunctions. The result
of all matrix on matrix operations are assumed to be <code class="code docutils literal notranslate"><span class="pre">ColMatrix</span></code> type. The result of Matrix*vector operations is <code class="code docutils literal notranslate"><span class="pre">VectorFunction</span></code>. You may also return
the transpose of an existing Row/ColMatrix. Furthermore, square matrices may be inverted resulting in a Matrix type with same row/col type. For now, one may only add matrices
together if they have the same Row/Col type, though we will support adding different Row/Col types in the future.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="c1">## Three orthonormal basis vectors</span>
<span class="n">Rhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">Nhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
<span class="n">That</span> <span class="o">=</span> <span class="n">Nhat</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Rhat</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>

<span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">Rhat</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">])</span>

<span class="n">RTNmatC</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">ColMatrix</span><span class="p">(</span><span class="n">RTNcoeffs</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Interpret as col major 3x3 Rotation matrix</span>
<span class="n">RTNmatR</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">RowMatrix</span><span class="p">(</span><span class="n">RTNcoeffs</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Interpret as row major 3x3 Rotation matrix</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">RTNmatC</span><span class="o">*</span><span class="n">RTNmatR</span> <span class="c1"># Multiply matrices together result is column major</span>

<span class="n">U1</span> <span class="o">=</span> <span class="n">RTNmatC</span><span class="o">*</span><span class="n">U</span>       <span class="c1"># Multiply on the right by a VectorFunction of size (3x1)</span>
<span class="n">U2</span> <span class="o">=</span> <span class="n">RTNmatR</span><span class="o">*</span><span class="n">U</span>
<span class="n">U3</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">U</span>

<span class="n">Zero</span> <span class="o">=</span> <span class="n">RTNmatR</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">*</span><span class="n">U</span> <span class="o">-</span><span class="n">RTNmatC</span><span class="o">*</span><span class="n">U</span>
<span class="n">Identity</span> <span class="o">=</span> <span class="n">RTNmatC</span><span class="o">*</span><span class="n">RTNmatC</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<span class="n">RTNmatC</span> <span class="o">+</span><span class="n">RTNmatC</span>
</pre></div>
</div>
</section>
<section id="conditional-statement-operations">
<h2>Conditional Statement/Operations<a class="headerlink" href="#conditional-statement-operations" title="Link to this heading">#</a></h2>
<p>ASSET’s intended use case is for defining constraints, objectives, and dynamical
models that will eventually be put to use inside of a second derivative optimizer. As a
general rule of thumb, it is a bad idea for such functions to contain conditional statements,
as this could potentially result in non-smooth derivatives. In these cases we always recommend considering
whether what you were trying to accomplish with the conditional statement can be reformulated in another way.
However, if this is not possible, or you are writing a function that will not see the inside of an optimizer,
we do offer support for simple conditional statements and boolean operations with VectorFunction expressions.
To be precise, we support constructing boolean statements involving the outputs of scalar valued functions, and then
using those as conditional statements to control the output of another expression. Conditional statements are constructed by
applying the comparison operators (&gt;,&lt;,&lt;=,&gt;=) to the outputs of ScalarFunctions. This can be used to dispatch one of
two functions using the <code class="code docutils literal notranslate"><span class="pre">vf.ifelse()</span></code> function as shown below. Note that the output sizes of both the true and false functions
MUST be the same. Conditional statements may also be combined together using the bitwise or/and operators (<a href="#id1"><span class="problematic" id="id2">|</span></a>,&amp;).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="n">condition</span> <span class="o">=</span> <span class="n">x0</span><span class="o">&lt;</span><span class="mf">1.0</span>

<span class="n">output_if_true</span> <span class="o">=</span> <span class="n">x1</span><span class="o">*</span><span class="mi">2</span>
<span class="n">output_if_false</span> <span class="o">=</span> <span class="n">x1</span><span class="o">+</span><span class="n">x2</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="n">output_if_true</span><span class="p">,</span><span class="n">output_if_false</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [4.0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [5.0]</span>


<span class="n">Fine</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">),</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">x1</span><span class="p">))</span>
<span class="c1">#Error = vf.ifelse(condition,vf.stack(x1,x2),output_if_false)</span>


<span class="n">combo_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span><span class="o">&lt;</span><span class="mf">1.0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">x0</span><span class="o">&gt;</span><span class="n">x1</span><span class="p">)</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">ifelse</span><span class="p">(</span><span class="n">combo_condition</span><span class="p">,</span><span class="n">output_if_true</span><span class="p">,</span><span class="n">output_if_false</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [4.0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [5.0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mf">2.5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># prints [4.0]</span>
</pre></div>
</div>
</section>
<section id="some-notes-on-input-arguments">
<h2>Some Notes on Input Arguments<a class="headerlink" href="#some-notes-on-input-arguments" title="Link to this heading">#</a></h2>
<p>Before moving on any further, we need to make one very important note about how the VectorFunction type system works. In all of our previous examples, we have created and partitioned
one set of arguments of a certain size, from which we constructed other functions. You might
ask, what happens if we try to mix expressions formulated out of arguments of different sizes?
This is strictly not allowed, as our entire type system is predicated on the fact that expressions can
only be combined if they have the same sized input arguments. For example, the following code will
throw an error to alert you that you have made a mistake. However, we should also note as shown below,
that there is nothing unique about any two sets of arguments of the same size. Thus, you may (though it is pointless)
combine expressions derived from two arguments objects of the same size.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X1</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">X2</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">X3</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="n">R1</span><span class="p">,</span><span class="n">V1</span><span class="p">,</span><span class="n">U1</span> <span class="o">=</span> <span class="n">X1</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="n">R2</span><span class="p">,</span><span class="n">V2</span><span class="p">,</span><span class="n">U2</span> <span class="o">=</span> <span class="n">X2</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="n">R3</span><span class="p">,</span><span class="n">V3</span><span class="p">,</span><span class="n">U3</span> <span class="o">=</span> <span class="n">X3</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="c1">#Error = R1 + R2</span>
<span class="c1">#Error = R1.dot(V2)</span>

<span class="c1">## These two functions do identical things</span>
<span class="n">Fine</span> <span class="o">=</span> <span class="n">R2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V3</span><span class="p">)</span>
<span class="n">Fine</span> <span class="o">=</span> <span class="n">R3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="suggested-style-and-organization">
<span id="vfstyle-guide"></span><h2>Suggested Style and Organization<a class="headerlink" href="#suggested-style-and-organization" title="Link to this heading">#</a></h2>
<p>At this point we have covered most all of the operations one can and can’t perform with ASSET
VectorFunctions, with the important exception of function composition
(which we will cover in the next section). As you might have noticed, in all of
our scratch pad examples, we simply created a single set of arguments and operated on them
in the same scope. Every one of these functions is a fully formed ASSET type and can be immediately passed
off to other parts of the library to be used as constraints/ODEs/controllers etc. However, obviously it is not a recipe
for longterm success to simply write expressions inline wherever they are needed. How you package or
encapsulate the construction of ASSET VectorFunctions is up to you, but we suggest one of the following two methods.</p>
<p>Method one involves simply writing a standard python function that takes as arguments
any meta data or constants, needed to define the function, then writing and returning your ASSET
VectorFunction. A trivial example of this is shown below, and you can find many others throughout our
problem specific examples contained in other sections.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">FuncMethod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
        <span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">eq1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span><span class="n">a</span> <span class="o">-</span> <span class="n">x1</span>
        <span class="n">eq2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">x1</span><span class="o">*</span><span class="n">c</span>
        <span class="k">return</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span><span class="n">eq2</span><span class="p">)</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">FuncMethod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># prints [1,5]</span>
</pre></div>
</div>
<p>Method two involves defining a new class that inherits from the appropriate
ASSET type (<code class="code docutils literal notranslate"><span class="pre">vf.VectorFunction</span></code> if output size is &gt;1, <code class="code docutils literal notranslate"><span class="pre">vf.ScalarFunction</span></code> if output size =1)
and then defining and initializing the expression in the constructor. This method should only
be preferred if you need to store the meta-data as part of the class
or add additional methods to the object. Otherwise, this method is functionally identical to
the one above.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FuncClass</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">VectorFunction</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span><span class="n">a</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span><span class="n">b</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span><span class="n">c</span>

                <span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">eq1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span><span class="n">a</span> <span class="o">-</span> <span class="n">x1</span>
                <span class="n">eq2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">x1</span><span class="o">*</span><span class="n">c</span>

                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span><span class="n">eq2</span><span class="p">))</span> <span class="c1">#Do not forget to call CTOR of Base!!</span>

        <span class="k">def</span> <span class="nf">get_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">FuncClass</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># prints [1,5]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">get_a</span><span class="p">())</span>   <span class="c1"># prints 1</span>
</pre></div>
</div>
</section>
<section id="function-composition">
<h2>Function Composition<a class="headerlink" href="#function-composition" title="Link to this heading">#</a></h2>
<p>Now that we have a good understanding of the rules and style for defining
single VectorFunctions, we can cover how to call them inside of other functions.
For this final example let us tackle a concrete problem that occurs
in astrodynamics: frame conversions. Specifically, we wish to write a function that takes
the position and velocity of some object in Cartesian coordinates, as well as some other vector,
and then transforms that vector into the RTN frame. The RTN basis vectors can be computed purely as a function
of position and velocity, so let us first write a function that does just that.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RTNBasis</span><span class="p">():</span>

        <span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

        <span class="n">Rhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
        <span class="n">Nhat</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
        <span class="n">That</span> <span class="o">=</span> <span class="n">Nhat</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">Rhat</span><span class="p">,</span><span class="n">That</span><span class="p">,</span><span class="n">Nhat</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then write another function that takes position and velocity as well as the vector
to be transformed. We then instantiate our previously defined function that
computes basis vectors and then “call” it with the position and velocity arguments
defined inside our new function. Calling the already instantiated function can be accomplished
by passing other VectorFunctions, to the <code class="code docutils literal notranslate"><span class="pre">()</span></code> call operator the same way we do for
real number arguments. In this case, providing the contiguous segment of size 6 <code class="code docutils literal notranslate"><span class="pre">RV</span></code>, is the most efficient
way to the define the expression. However, if this were not the case, we could also use the other
call signatures shown. We can provide two separate functions, in this case <code class="code docutils literal notranslate"><span class="pre">R</span></code> and <code class="code docutils literal notranslate"><span class="pre">V</span></code>,
either as individual arguments or grouped together in a python list. These will be implicitly
stacked using the same rules governing <code class="code docutils literal notranslate"><span class="pre">vf.stack</span></code> and then forwarded to the function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RTNTransform</span><span class="p">():</span>


        <span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>

        <span class="n">RV</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

        <span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

        <span class="n">RTNBasisFunc</span> <span class="o">=</span> <span class="n">RTNBasis</span><span class="p">()</span> <span class="c1"># Instantiate function object</span>


        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">(</span><span class="n">RV</span><span class="p">)</span>  <span class="c1">### Call Function at new vectorfunction arguments</span>

        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">)</span> <span class="c1"># Same effect as original but slower</span>
        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">))</span> <span class="c1"># Does Exactly the same thing as above calls stack on R,V explicitly</span>

        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">])</span> <span class="c1"># Same effect as original but slower</span>
        <span class="n">RTNcoeffs</span> <span class="o">=</span> <span class="n">RTNBasisFunc</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">V</span><span class="p">]))</span> <span class="c1"># Does Exactly the same thing as above calls stack on [R,V] explicitly</span>



        <span class="n">RTNmat</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">RowMatrix</span><span class="p">(</span><span class="n">RTNcoeffs</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">U_RTN</span> <span class="o">=</span> <span class="n">RTNmat</span><span class="o">*</span><span class="n">U</span>

        <span class="k">return</span> <span class="n">U_RTN</span>
</pre></div>
</div>
</section>
<section id="repeated-sub-expressions">
<h2>Repeated Sub Expressions<a class="headerlink" href="#repeated-sub-expressions" title="Link to this heading">#</a></h2>
<p>Being a functional programming language, it is important to note that an ASSET
expression is evaluated everywhere it appears in a statement. There is no notion
of assigning it to a temporary variable and then reusing it later without recalculating it.
For example, in the following code, just because we bind the complicated expression to
the name <code class="code docutils literal notranslate"><span class="pre">expensive</span></code>, the function <code class="code docutils literal notranslate"><span class="pre">answer</span></code> will still require actually
evaluating <code class="code docutils literal notranslate"><span class="pre">expensive</span></code> three times.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="n">expensive</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">normalized_power3</span><span class="p">())</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="n">V</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()))</span><span class="o">**</span><span class="mf">3.14</span>

<span class="n">answer</span> <span class="o">=</span> <span class="n">R</span><span class="o">+</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">expensive</span><span class="p">,</span><span class="n">expensive</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">expensive</span><span class="p">)</span>
</pre></div>
</div>
<p>In the vast majority of cases you should not worry about the cost of reevaluating subexpressions,
as the run time hit is marginal. There is, however, one way to explicitly reduce the cost of expensive repeated
sub expressions, should you need to. You can do this by writing a second function where the subexpression appears
linearly as additional arguments or segments and then using the call operator to compose this new function
and the original arguments and subexpression together. For example, the following code will produce the same output
as above while only ever evaluating <code class="code docutils literal notranslate"><span class="pre">expensive</span></code> once.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

<span class="n">expensive</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">normalized_power3</span><span class="p">())</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="n">V</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()))</span><span class="o">**</span><span class="mf">3.14</span>


<span class="c1">## New args for defining function of only R and expensive</span>
<span class="n">R_temp</span><span class="p">,</span> <span class="n">expensive_tmp</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>

<span class="n">answer_tmp</span> <span class="o">=</span> <span class="n">R_temp</span><span class="o">+</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">expensive_tmp</span><span class="p">,</span><span class="n">expensive_tmp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">expensive_tmp</span><span class="p">)</span>

<span class="n">answer</span> <span class="o">=</span> <span class="n">answer_tmp</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">expensive</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="tabular-data-and-interpolation">
<h2>Tabular Data and Interpolation<a class="headerlink" href="#tabular-data-and-interpolation" title="Link to this heading">#</a></h2>
<p>We also have support for interpreting tabular data as a VectorFunction using differentiable interpolation table objects.</p>
<section id="d-interpolation">
<h3>1-D Interpolation<a class="headerlink" href="#d-interpolation" title="Link to this heading">#</a></h3>
<p>Interpolation of vector or scalar data with one input dimension may be accomplished using <code class="code docutils literal notranslate"><span class="pre">vf.InterpTable1D</span></code>. This
class is designed to be constructed and behave similarly to scipy’s <code class="code docutils literal notranslate"><span class="pre">interp1D</span></code> class. To construct a table for interpolating
vector data, we pass a list of sorted coordinate values along with an array whose rows or columns are the vectors of values at
each coordinate. You may also pass in the data as a list of numpy arrays or lists which include the coordinate element. You have the
option to choose between linear or cubic interpolation using the kind parameter in the constructor. Cubic interpolation is recommended to ensure
that the function is twice differentiable.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>

<span class="n">VecDat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">])</span>

<span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span> <span class="c1"># or &#39;linear&#39;</span>

<span class="n">Tab</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">InterpTable1D</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">VecDat</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span> <span class="c1">#prints [1,.0]</span>

<span class="c1"># Or if data is transposed</span>
<span class="n">Tab</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">InterpTable1D</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">VecDat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span> <span class="c1">#prints [1,.0]</span>

<span class="c1"># Or if data is a list of arrays or lists with time included as one the elements</span>
<span class="n">VecList</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">]</span>

<span class="n">Tab</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">InterpTable1D</span><span class="p">(</span><span class="n">VecList</span><span class="p">,</span><span class="n">tvar</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span> <span class="c1">#prints [1,.0]</span>
</pre></div>
</div>
<p>To construct a table for interpolating scalar data, you may just pass in the list of coordinates along with a
1-D numpy array or python list of the values of the function at each point.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ScalDat</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">]</span>
<span class="n">STab</span> <span class="o">=</span><span class="n">vf</span><span class="o">.</span><span class="n">InterpTable1D</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">ScalDat</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">STab</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span> <span class="c1"># prints [1.0]</span>
</pre></div>
</div>
<p>The outputs of <code class="code docutils literal notranslate"><span class="pre">vf.InterpTable1D</span></code> are only well defined within the domain of the supplied coordinates. By default attempts
to interpolate outside of the domain will result in inaccurate extrapolation and print a warning the screen. This
can be disabled using the <code class="code docutils literal notranslate"><span class="pre">.WarnOutOfBounds</span></code> field of the object. Additionally, you may specify that you would like an exception
to be thrown when this occurs by setting <code class="code docutils literal notranslate"><span class="pre">.ThrowOutOfBounds</span></code> to <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Tab</span><span class="o">.</span><span class="n">WarnOutOfBounds</span><span class="o">=</span><span class="kc">True</span>   <span class="c1"># By default</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab</span><span class="p">(</span><span class="o">-</span><span class="mf">.00001</span><span class="p">))</span>        <span class="c1"># prints [-1.0e-5,1] and a warning</span>
<span class="n">Tab</span><span class="o">.</span><span class="n">ThrowOutOfBounds</span><span class="o">=</span><span class="kc">True</span>
<span class="c1">#print(Tab(-.00001))       # throws an exception</span>
</pre></div>
</div>
<p>Once you have constructed a table object, it can be composed with other ASSET VectorFunctions or ScalarFunctions
by providing a ScalarFunction argument to the call operator.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>

<span class="n">f1</span> <span class="o">=</span> <span class="n">STab</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span>  <span class="c1"># STab(t) is an asset scalar function</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">Tab</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">V</span>   <span class="c1"># Tab(t) is an asset vector function</span>
</pre></div>
</div>
</section>
<section id="id3">
<h3>2-D Interpolation<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<p>Similarly, you can also interpret scalar data defined on a 2-D rectilinear grid of coordinates as an ASSET ScalarFunction using the
<code class="code docutils literal notranslate"><span class="pre">vf.InterpTable2D</span></code> class. The class may be constructed by supplying the grid coordinates as either python lists or numpy
arrays along with the function values formatted like a numpy meshgrid. The function values MUST be formatted like an xy indexed meshgrid,
which is the default behavior for np.meshgrid in 2 dimensions</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function values MUST be formatted like an xy indexed meshgrid.If you are
using np.meshgrid to generate the function values, take note that it assumes xy
indexing by default. If you index the values wrong and your coordinate dimensions
are the same size, we will not be able to detect an error.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nx</span> <span class="o">=</span><span class="mi">500</span>
<span class="n">ny</span> <span class="o">=</span><span class="mi">800</span>
<span class="n">lim</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">lim</span><span class="p">,</span><span class="n">lim</span><span class="p">,</span><span class="n">nx</span><span class="p">)</span>
<span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">lim</span><span class="p">,</span><span class="n">lim</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span><span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
<span class="n">Z</span>    <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>             <span class="c1">#Scalar data defined on 2-D meshgrid</span>

<span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span> <span class="c1"># or &#39;linear&#39;</span>

<span class="n">Tab2D</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">InterpTable2D</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Tab2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>  <span class="c1">#prints 1.0</span>


<span class="n">Tab2D</span><span class="o">.</span><span class="n">WarnOutOfBounds</span><span class="o">=</span><span class="kc">True</span>   <span class="c1"># By default</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab2D</span><span class="p">(</span><span class="o">-</span><span class="mf">6.3</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>        <span class="c1"># prints a warning</span>
<span class="n">Tab2D</span><span class="o">.</span><span class="n">ThrowOutOfBounds</span><span class="o">=</span><span class="kc">True</span>
<span class="c1">#print(Tab2D(-6.3,0))       # throws exception</span>
</pre></div>
</div>
<p>Once constructed, <code class="code docutils literal notranslate"><span class="pre">vf.InterpTable2D</span></code> can be converted into an ASSET ScalarFunction by supplying
the x and y coordinates to the table’s call operator as a singe VectorFunction or two separate ScalarFunctions .</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xy</span><span class="p">,</span><span class="n">c</span><span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="c1"># Use it as scalar function inside a statement</span>
<span class="n">Tab2sf</span> <span class="o">=</span> <span class="n">Tab2D</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
<span class="n">Tab2sf</span> <span class="o">=</span> <span class="n">Tab2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>             <span class="c1"># Or</span>
<span class="n">Tab2sf</span> <span class="o">=</span> <span class="n">Tab2D</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]))</span> <span class="c1"># Or</span>

<span class="n">Func</span> <span class="o">=</span> <span class="n">Tab2sf</span> <span class="o">+</span> <span class="n">c</span>   <span class="c1"># Use it as a normal scalar function</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Func</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]))</span>  <span class="c1"># prints [2.0]</span>
</pre></div>
</div>
</section>
<section id="id4">
<h3>3-D Interpolation<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>As of version 0.1.0, we also support interpolating scalar data defined on 3 dimensional rectilinear grids
with the <code class="code docutils literal notranslate"><span class="pre">vf.InterpTable3D</span></code> class. To construct it, we supply the coordinate values as three python
lists/numpy vectors along with the function values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function values MUST be formatted like an ij indexed meshgrid. If you are
using np.meshgrid to generate the function values, take note that it assumes xy indexing by default,
and this should be changed to ij.If you index the values wrong and your coordinate dimensions are the same size,
we will not be able to detect an error.</p>
</div>
<p>As with the 1D and 2D tables, you can also select between linear or cubic interpolation. Cubic interpolation should be
preferred for anything that will end up in an optimizer. Additionally, for cubic interpolation you can specify that
you want to pre-calculate and cache all possible values of the interpolation coefficients in each voxel of the domain.
This requires the up front calculation of  <code class="code docutils literal notranslate"><span class="pre">(nx-1)*(ny-1)*(nz-1)</span></code> matrix vector products of size (64x64)x(64x1)  and 8 times the storage of the non-cached
algorithm. However, interpolation will be 10-20 times faster. So use this if the dimensions are small and the interpolator
will be called a lot.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span><span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

<span class="n">nx</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">ny</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">nz</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">xlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">ylim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">zlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">xlim</span><span class="p">,</span><span class="n">xlim</span><span class="p">,</span><span class="n">nx</span><span class="p">)</span>
<span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ylim</span><span class="p">,</span><span class="n">ylim</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span>
<span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">zlim</span><span class="p">,</span><span class="n">zlim</span><span class="p">,</span><span class="n">nz</span><span class="p">)</span>

<span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">indexing</span> <span class="o">=</span> <span class="s1">&#39;ij&#39;</span><span class="p">)</span>
<span class="n">Fs</span>    <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>    <span class="c1">#Scalar data defined on 3-D meshgrid in ij format!!!</span>

<span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span> <span class="c1"># or &#39;linear&#39;, defaults to &#39;cubic&#39;</span>
<span class="n">cache</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># defaults to False</span>
<span class="c1">#cache = True # will precalculate and cache all interpolation coeffs</span>

<span class="n">Tab3D</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">InterpTable3D</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">Fs</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span><span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Tab3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>  <span class="c1">#prints 1.0</span>

<span class="n">Tab3D</span><span class="o">.</span><span class="n">WarnOutOfBounds</span><span class="o">=</span><span class="kc">True</span>   <span class="c1"># By default</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab3D</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>        <span class="c1"># prints a warning</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>        <span class="c1"># prints a warning</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">))</span>        <span class="c1"># prints a warning</span>

<span class="n">Tab3D</span><span class="o">.</span><span class="n">ThrowOutOfBounds</span><span class="o">=</span><span class="kc">True</span>
<span class="c1">#print(Tab3D(-10,0,0))       # throws exception</span>
</pre></div>
</div>
</section>
<section id="id5">
<h3>4-D Interpolation<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p>As of version 0.4.0, we also support interpolating scalar data defined on 4 dimensional rectilinear grids
with the <code class="code docutils literal notranslate"><span class="pre">vf.InterpTable4D</span></code> class. To construct it, we supply the coordinate values as four python
lists/numpy vectors along with the function values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function values MUST be formatted like an ij indexed meshgrid. If you are
using np.meshgrid to generate the function values, take note that it assumes xy indexing by default,
and this should be changed to ij.If you index the values wrong and your coordinate dimensions are the same size,
we will not be able to detect an error.</p>
</div>
<p>As with the previous tables, you can select between linear or cubic interpolation. Cubic interpolation should be
preferred for anything that will end up in an optimizer. Additionally, for cubic interpolation you can specify that
you want to pre-calculate and cache all possible values of the interpolation coefficients in each voxel of the domain.
This requires the up front calculation of  <code class="code docutils literal notranslate"><span class="pre">(nx-1)*(ny-1)*(nz-1)*(nw-1)</span></code> matrix vector products of size (256x256)x(256x1)  and 16 times the storage of the non-cached
algorithm. However, interpolation will be 5-6 times faster. So use this if the dimensions are small and the interpolator
will be called a lot.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">):</span><span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

<span class="n">nx</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">ny</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">nz</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">nw</span> <span class="o">=</span> <span class="mi">50</span>

<span class="n">xlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">ylim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">zlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">wlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">xlim</span><span class="p">,</span><span class="n">xlim</span><span class="p">,</span><span class="n">nx</span><span class="p">)</span>
<span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ylim</span><span class="p">,</span><span class="n">ylim</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span>
<span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">zlim</span><span class="p">,</span><span class="n">zlim</span><span class="p">,</span><span class="n">nz</span><span class="p">)</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">zlim</span><span class="p">,</span><span class="n">zlim</span><span class="p">,</span><span class="n">nw</span><span class="p">)</span>


<span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">ws</span><span class="p">,</span><span class="n">indexing</span> <span class="o">=</span> <span class="s1">&#39;ij&#39;</span><span class="p">)</span>
<span class="n">Fs</span>    <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">W</span><span class="p">)</span>    <span class="c1">#Scalar data defined on 4-D meshgrid in ij format!!!</span>

<span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span> <span class="c1"># or &#39;linear&#39;, defaults to &#39;cubic&#39;</span>
<span class="n">cache</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># defaults to False</span>
<span class="c1">#cache = True # will precalculate and cache all interpolation coeffs</span>

<span class="n">Tab4D</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">InterpTable4D</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">ws</span><span class="p">,</span><span class="n">Fs</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span><span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Tab4D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>  <span class="c1">#prints 1.0</span>

<span class="n">Tab4D</span><span class="o">.</span><span class="n">WarnOutOfBounds</span><span class="o">=</span><span class="kc">True</span>   <span class="c1"># By default</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab4D</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>        <span class="c1"># prints a warning</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab4D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>        <span class="c1"># prints a warning</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab4D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>        <span class="c1"># prints a warning</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Tab4D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">))</span>        <span class="c1"># prints a warning</span>

<span class="n">Tab3D</span><span class="o">.</span><span class="n">ThrowOutOfBounds</span><span class="o">=</span><span class="kc">True</span>
<span class="c1">#print(Tab3D(-10,0,0,0))       # throws exception</span>
</pre></div>
</div>
<p>Once constructed, <code class="code docutils literal notranslate"><span class="pre">vf.InterpTable4D</span></code> can be converted into an ASSET ScalarFunction by supplying
the x,y,z, and w coordinates to the table’s call operator as a singe VectorFunction or four separate ScalarFunctions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">xyzw</span><span class="p">,</span><span class="n">c</span><span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="c1"># Use it as scalar function inside a statement</span>
<span class="n">Tab4sf</span> <span class="o">=</span> <span class="n">Tab4D</span><span class="p">(</span><span class="n">xyzw</span><span class="p">)</span>
<span class="n">Tab4sf</span> <span class="o">=</span> <span class="n">Tab4D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>             <span class="c1"># Or</span>
<span class="n">Tab4sf</span> <span class="o">=</span> <span class="n">Tab4D</span><span class="p">(</span><span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">]))</span> <span class="c1"># Or</span>

<span class="n">Func</span> <span class="o">=</span> <span class="n">Tab4sf</span> <span class="o">+</span> <span class="n">c</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Func</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># prints [2.0]</span>
</pre></div>
</div>
</section>
</section>
<section id="note-on-size-of-vectorfunctions">
<h2>Note on Size of VectorFunctions<a class="headerlink" href="#note-on-size-of-vectorfunctions" title="Link to this heading">#</a></h2>
<p>The VectorFunction type system has been designed to have good performance for evaluating
the value and derivatives of dense VectorFunctions with a small number of arguments (&lt;50).
It will work for larger expressions, but performance will begin to degrade considerably. This may seem
strange since it is ostensibly designed to be used to define constraints and objective inside of large
sparse non-linear programs. However, in our experience these problems are almost never composed
of single monolithic functions, and can generally be decomposed into smaller dense functions that only
take partial subsets of the problem variables. In that case, we can define our functions in terms of
only the arguments they take, and then under the hood, ASSET will ensure that the inputs and outputs are gathered and
scattered to the correct locations inside the larger problem. The specifics of how this works will be discussed in later
sections.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># Legal but Bad</span>
</pre></div>
</div>
</section>
<section id="binding-raw-python-functions-don-t-do-this">
<h2>Binding Raw Python Functions (DON’T DO THIS)<a class="headerlink" href="#binding-raw-python-functions-don-t-do-this" title="Link to this heading">#</a></h2>
<p>You also have the option, should you need to, to bind raw python functions
as ASSET VectorFunctions and ScalarFunctions. This can be accomplished using the <code class="code docutils literal notranslate"><span class="pre">vf.PyVectorFunction</span></code>
and  <code class="code docutils literal notranslate"><span class="pre">vf.PyScalarFunction</span></code> types as shown below. The function must have a signature accepting as the first argument a 1 dimensional numpy array of input arguments
(named <code class="code docutils literal notranslate"><span class="pre">X</span></code> in this case) and returning a numpy array. Additional parameters on which the implementation depends (these are not mathematical input variables) may be included as additional
arguments.
You must also explicitly state the input and output (if not scalar) sizes of the function. The function jacobian and hessian will be computed with finite differences
using the user specified jacobian and hessian step sizes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># A vector function</span>
<span class="k">def</span> <span class="nf">VFunc</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">])</span>

<span class="n">InputSize</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">OutputSize</span> <span class="o">=</span><span class="mi">2</span>

<span class="n">PyVfunc</span> <span class="o">=</span><span class="n">vf</span><span class="o">.</span><span class="n">PyVectorFunction</span><span class="p">(</span><span class="n">InputSize</span><span class="p">,</span><span class="n">OutputSize</span><span class="p">,</span><span class="n">VFunc</span><span class="p">,</span><span class="n">Jstepsize</span><span class="o">=</span><span class="mf">1.0e-6</span><span class="p">,</span><span class="n">Hstepsize</span><span class="o">=</span><span class="mf">1.0e-4</span><span class="p">,</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span> <span class="c1">## a and b will be 2</span>

<span class="nb">print</span><span class="p">(</span><span class="n">PyVfunc</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>  <span class="c1"># prints [12,14]</span>


<span class="c1"># A scalar function</span>
<span class="k">def</span> <span class="nf">SFunc</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">])</span> <span class="c1"># output is 1x1 array</span>

<span class="n">InputSize</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">PySfunc</span> <span class="o">=</span><span class="n">vf</span><span class="o">.</span><span class="n">PyScalarFunction</span><span class="p">(</span><span class="n">InputSize</span><span class="p">,</span><span class="n">SFunc</span><span class="p">,</span><span class="n">Jstepsize</span><span class="o">=</span><span class="mf">1.0e-6</span><span class="p">,</span><span class="n">Hstepsize</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>You should be warned that extensive use of these objects inside of the optimizer or an ODE will result in VERY slow and non-parrallelizable code with inexact derivatives.
If you find yourself in a situation where you don’t think you can write an expression without using <code class="code docutils literal notranslate"><span class="pre">vf.PyVectorFunction</span></code> or <code class="code docutils literal notranslate"><span class="pre">vf.PyScalarFunction</span></code>,
please submit an issue on GitHub. We will happily give suggestions on how you might be able to accomplish your task with the standard VectorFunctions.
If it’s truly not possible, we will consider adding the missing expression to the core library in a future release.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="ODEGuide.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">ODE Tutorial</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="Install.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Installing ASSET</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022-2023, UA ASRL
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Vector Function Tutorial</a><ul>
<li><a class="reference internal" href="#arguments">Arguments</a></li>
<li><a class="reference internal" href="#standard-math-operations">Standard Math Operations</a></li>
<li><a class="reference internal" href="#scalar-math-operations">Scalar Math Operations</a></li>
<li><a class="reference internal" href="#vector-norms-and-normalizations">Vector Norms and Normalizations</a></li>
<li><a class="reference internal" href="#vector-products">Vector Products</a></li>
<li><a class="reference internal" href="#stacking-outputs">Stacking Outputs</a></li>
<li><a class="reference internal" href="#matrix-operations">Matrix Operations</a></li>
<li><a class="reference internal" href="#conditional-statement-operations">Conditional Statement/Operations</a></li>
<li><a class="reference internal" href="#some-notes-on-input-arguments">Some Notes on Input Arguments</a></li>
<li><a class="reference internal" href="#suggested-style-and-organization">Suggested Style and Organization</a></li>
<li><a class="reference internal" href="#function-composition">Function Composition</a></li>
<li><a class="reference internal" href="#repeated-sub-expressions">Repeated Sub Expressions</a></li>
<li><a class="reference internal" href="#tabular-data-and-interpolation">Tabular Data and Interpolation</a><ul>
<li><a class="reference internal" href="#d-interpolation">1-D Interpolation</a></li>
<li><a class="reference internal" href="#id3">2-D Interpolation</a></li>
<li><a class="reference internal" href="#id4">3-D Interpolation</a></li>
<li><a class="reference internal" href="#id5">4-D Interpolation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#note-on-size-of-vectorfunctions">Note on Size of VectorFunctions</a></li>
<li><a class="reference internal" href="#binding-raw-python-functions-don-t-do-this">Binding Raw Python Functions (DON’T DO THIS)</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=e259d695"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=32e29ea5"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>