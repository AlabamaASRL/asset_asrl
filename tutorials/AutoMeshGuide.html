<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Optimal Control Utilities" href="OptimalControlUtilites.html" /><link rel="prev" title="PSIOPT" href="PSIOPT.html" />

    <!-- Generated with Sphinx 6.2.1 and Furo 2023.05.20 -->
        <title>Adaptive Mesh Refinement Tutorial - ASSET 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=e6660623a769aa55fea372102b9bf3151b292993" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: red;
  --color-brand-content: #CC3333;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ASSET 0.2.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/ASSETLOGO.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ASSET 0.2.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="tutorials.html">Tutorials</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Install.html">Installing ASSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="VectorFunctionGuide.html">Vector Function Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ODEGuide.html">ODE Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="IntegratorGuide.html">Integrator Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="PhaseGuide.html">Optimal Control Phase Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptimalControlProblem.html">Optimal Control Problem Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="PSIOPT.html">PSIOPT</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Adaptive Mesh Refinement Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptimalControlUtilites.html">Optimal Control Utilities</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../examples/examples.html">Examples</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Examples</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples/Delta3.html">Delta 3 Multi-phase GTO Transfer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ReentryExample.html">Space Shuttle Reentry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/CartPole.html">Cart-Pole Swing Up</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/HyperSensitive.html">Hyper-Sensitive Optimal Control Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/halo.html">Orbit Family Continuation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/zermelo.html">Zermelo’s Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/zermelolink.html">Multi-Phase Zermelo’s Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/MultiTarg.html">Multi-Spacecraft Optimization</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../python/python.html">Python Library Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Python Library Documentation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../python/asset.html">ASSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/optimalcontrol.html">Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/vectorfunctions.html">Vector Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/Astro.html">ASSET Astro Library</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="adaptive-mesh-refinement-tutorial">
<span id="mesh-guide"></span><h1>Adaptive Mesh Refinement Tutorial<a class="headerlink" href="#adaptive-mesh-refinement-tutorial" title="Permalink to this heading">#</a></h1>
<p>In version 0.1.0, we have added significantly improved capabilities for automatic mesh refinement for problems
defined through the phase and OptimalControlProblem interfaces.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These new features are entirely opt-in, and any old code “should” work exactly as it did before.</p>
</div>
<section id="mathematical-background">
<h2>Mathematical Background<a class="headerlink" href="#mathematical-background" title="Permalink to this heading">#</a></h2>
<p>Given a mesh with <span class="math notranslate nohighlight">\(N\)</span> LGL segments of order <span class="math notranslate nohighlight">\(p\)</span>, the algorithm first estimates the maximum error <span class="math notranslate nohighlight">\(e_i\)</span> in the ith segment spanning the time interval <span class="math notranslate nohighlight">\([t_i,t_{i+1}]\)</span>.
We have implemented two methods to obtain these error estimates.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[e_i \quad \text{on} \quad [t_i,t_{i+1}] \quad i = 1 \ldots N\]</div>
</div>
<p>The first, which we refer to as de Boor’s method,  estimates the error from the <span class="math notranslate nohighlight">\(p+1\)</span> th derivative, <span class="math notranslate nohighlight">\(\vec{X}^{'(p+1)}\)</span> , of the solution as shown below [1,2,3].</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[e_i = C*h_i^{p+1} * |\vec{X}^{'(p+1)}|_{\infty} \quad \text{where} \quad h_i = t_{i+1} -t_{i}\]</div>
</div>
<p>Since the solution is a piecewise polynomial of order <span class="math notranslate nohighlight">\(p\)</span>, <span class="math notranslate nohighlight">\(\vec{X}^{'(p+1)}\)</span> is calculated using the differencing scheme described by de Boor[1]. The error coefficient, <span class="math notranslate nohighlight">\(C\)</span>, associated with an LGL method
of order <span class="math notranslate nohighlight">\(p\)</span> can be calculated using the method described by Russell [2].</p>
<p>For the second error estimation scheme, we calculate <span class="math notranslate nohighlight">\(e_i\)</span> by reintegrating the solution between all collocation points within each segment, and calculating the average error between the
integrated states and the collocation solution.</p>
<p>For well behaved problems, and sufficient numbers of segments, these error estimates agree well with one another. However, in certain circumstances one may be superior to the other.
For example, the integration method more accurately estimates the true error on a coarse mesh. However, for some stiff problems, explicit integration can be extremely slow or worse, fail, while de Boor’s method will be unaffected.</p>
<p>Having calculated the error <span class="math notranslate nohighlight">\(e_i\)</span> in each segment with either of the two methods, we then estimate the number of segments that will reduce <span class="math notranslate nohighlight">\(e_i\)</span> below some user specified tolerance. This estimate
is obtained by summing up the fractional number of segments that each individual segment of the initial mesh
would need to be divided into in order to meet the tolerance <span class="math notranslate nohighlight">\(\frac{\epsilon}{\sigma}\)</span>. Here <span class="math notranslate nohighlight">\(\epsilon\)</span> is the user defined
mesh error tolerance, and <span class="math notranslate nohighlight">\(\sigma\)</span> is a user defined factor that exaggerates the error in each segment. The user defined <span class="math notranslate nohighlight">\(\kappa\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span> factors enforce a maximum reduction and increase in
the number of segments in the next mesh respectively. We have found that this sum of fractional segments works better for our purposes than using the average value of <span class="math notranslate nohighlight">\(e_i\)</span> as is done in [3].</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[^+N = \text{ceil}\left[ \text{min}\left[  \sum_{1}^{N} \text{max}\left(  \left(\frac{\sigma*e_i}{\epsilon}\right)^{\frac{1}{p+1}}  ,\kappa\right) ,\gamma*N\right]\right]\]</div>
</div>
<p>Next, we calculate a new mesh spacing with <span class="math notranslate nohighlight">\(^+N\)</span> time intervals with approximately equal error.
This is done by first constructing a piece-wise constant error distribution function <span class="math notranslate nohighlight">\(E(t)\)</span> from our previous mesh as shown below [3].</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[E(t) = \frac{e_i^{\frac{1}{p+1}}}{h_i} \quad \text{on} \quad [t_i,t_{i+1}];\]</div>
</div>
<p>We then integrate and normalize this error distribution to obtain a piece-wise linear cumulative error function <span class="math notranslate nohighlight">\(\bar{I}(t)\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\bar{I}(t) = \frac{I(t)}{I(t_{N+1})} \quad \text{where} \quad I(t) = \int_{t_1}^{t_{N+1}} E(t) dt\]</div>
</div>
<p>The new mesh’s times are then are then chosen by evaluating the functional inverse, <span class="math notranslate nohighlight">\(\bar{I}^{-1}(x)\)</span>, of the cumulative error function on an evenly spaced
grid of <span class="math notranslate nohighlight">\(^+N + 1\)</span> points on the interval <span class="math notranslate nohighlight">\([0,1]\)</span> [3].</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[^+t_i = \bar{I}^{-1}\left(\frac{i}{^+N }\right) \quad i = 0 \ldots ^+N\]</div>
</div>
<p>At this point, we construct a new mesh at these time points from our old one and resolve/optimize the trajectory. This entire process repeats until the maximum error <span class="math notranslate nohighlight">\(e_i\)</span>
is reduced below <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Our formulation allows all of the mesh times to translate and dilate/expand as needed during solving/optimization, but the relative non-dimensional spacing of times is constrained to remain constant.</p>
</div>
</section>
<section id="phase">
<h2>Phase<a class="headerlink" href="#phase" title="Permalink to this heading">#</a></h2>
<p>To enable the new adaptive mesh algorithm on a phase you need to call the object’s <code class="code docutils literal notranslate"><span class="pre">.setAdaptiveMesh</span></code> method prior to invoking the optimizer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">phase</span><span class="o">.</span><span class="n">setAdaptiveMesh</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>  <span class="c1">#Enable Adaptive mesh for all following solve/optimize calls</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setAdaptiveMesh</span><span class="p">()</span>      <span class="c1">#Equivalent to above</span>

<span class="c1">#phase.setAdaptiveMesh(False) #Or Disable it if turned on</span>
</pre></div>
</div>
<p>The error estimation method discussed in the previous section can be selected by calling the phases’s <code class="code docutils literal notranslate"><span class="pre">.setMeshErrorEstimator</span></code> function.
Remember, when using the <code class="code docutils literal notranslate"><span class="pre">&quot;integrator&quot;</span></code> method, all integration will done using the <code class="code docutils literal notranslate"><span class="pre">.integrator</span></code> object attached to the phase. Therefore, if the default tolerances
and step sizes are inappropriate for your problem, you should modify them.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrorEstimator</span><span class="p">(</span><span class="s1">&#39;deboor&#39;</span><span class="p">)</span>     <span class="c1">#default</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrorEstimator</span><span class="p">(</span><span class="s1">&#39;integrator&#39;</span><span class="p">)</span>

<span class="c1"># Make sure the integrator is configured correctly for you problem</span>
<span class="n">phase</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">setAbsTol</span><span class="p">(</span><span class="mf">1.0e-10</span><span class="p">)</span>        <span class="c1"># Recall,defaults to 1.0e-12</span>
<span class="n">phase</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">setRelTol</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)</span>        <span class="c1"># Recall,defaults to 0.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">setStepSizes</span><span class="p">(</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.001</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Recall,defaults to .1,.1/10000,.1*10000</span>
</pre></div>
</div>
<p>The mesh tolerance and max number of mesh iterations can be specified with the <code class="code docutils literal notranslate"><span class="pre">.setMeshTol</span></code> and <code class="code docutils literal notranslate"><span class="pre">.setMaxMeshIters</span></code> functions of the phase.
As a general rule of thumb, you should set the optimizer’s equality constraint tolerance to be the same as or smaller than the mesh tolerance.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">## Set Error tolerance on mesh (epsilon)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMeshTol</span><span class="p">(</span><span class="mf">1.0e-7</span><span class="p">)</span>  <span class="c1">#default = 1.0e-6</span>
<span class="c1">## Make sure to set optimizer EContol to be the same as or smaller than MeshTol</span>
<span class="n">phase</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">set_EContol</span><span class="p">(</span><span class="mf">1.0e-7</span><span class="p">)</span>

<span class="c1">## Set Max number of mesh iterations:</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMaxMeshIters</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1">#default = 10</span>
</pre></div>
</div>
<p>The hyper parameters, <span class="math notranslate nohighlight">\(\sigma\)</span>, <span class="math notranslate nohighlight">\(\kappa\)</span> , and <span class="math notranslate nohighlight">\(\gamma\)</span>  of the mesh refinement algorithm can be set as shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">## (sigma) Mesh Error exaggeration factor</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrFactor</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>  <span class="c1">#default = 10</span>

<span class="c1">## (kappa) Minimum multiple by which the # of segments can be reduced between iterations</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMeshRedFactor</span><span class="p">(</span><span class="mf">.5</span><span class="p">)</span>  <span class="c1">#default = .5</span>

<span class="c1">## (gamma) Maximum multiple by which the # of segments can be increased between iterations</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMeshIncFactor</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>  <span class="c1"># default = 5</span>

<span class="n">phase</span><span class="o">.</span><span class="n">setMinSegments</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>      <span class="c1"># default = 4</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMaxSegments</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>  <span class="c1"># default = 10000</span>
</pre></div>
</div>
<p>Finally, you may also change the criteria used to determine whether the mesh has converged. By default, we consider the mesh converged when
<span class="math notranslate nohighlight">\(\text{max}[e_1, \ldots,e_N] &lt;\epsilon\)</span>. However, you can loosen this to converge when the time weighted average value of all <span class="math notranslate nohighlight">\(e_i\)</span> satisfies the tolerance.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\left( \sum_1^N e_i h_i\right) \frac{1}{t_{N+1}-t_1} &lt; \epsilon\]</div>
</div>
<p>Alternatively, you can set the convergence criteria to be the maximum error between the terminal state of the collocation solution
and one calculated by explicitly integrating the initial state and entire control history from the beginning to the end of the trajectory.</p>
<p>These mesh error criteria may be set as shown below. As with the integrator based local error estimator, for <code class="code docutils literal notranslate"><span class="pre">'endtoend'</span></code> the phases integrator instance will be used to
reintegrate the control history, so modify tolerances and step sizes accordingly. Additionally, since the end to end error estimate is decoupled from the
per segment error estimates used to generate the new mesh, users should be more aggressive with the mesh error exaggeration factor.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrorCriteria</span><span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">)</span>  <span class="c1"># default</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrorCriteria</span><span class="p">(</span><span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrorCriteria</span><span class="p">(</span><span class="s1">&#39;endtoend&#39;</span><span class="p">)</span>

<span class="c1"># If endtoend you might want to increase this parameter</span>
<span class="c1">#phase.setMeshErrFactor(50.0)</span>
</pre></div>
</div>
<p>Finally, having specified all relevant parameters, we can solve or optimize the phase as we normally would. However, now
at each mesh iteration, additional information (see figure) pertaining to the progress of the refinement process will be printed along with the normal optimizer output.
As in the non-adaptive case, the flag returned by the call is the convergence flag of the last call made to PSIOPT. It does not indicate whether the mesh meets the error
tolerances. That is checked by reading the read-only <code class="code docutils literal notranslate"><span class="pre">.MeshConverged</span></code> field of the phase.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If adaptive mesh refinement has not been enabled, .MeshConverged has no meaning and will be false!!</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># (Optional) Suppress optimizer output to only convergence status</span>
<span class="n">phase</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">PrintLevel</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Enable or disable printing mesh info</span>
<span class="n">phase</span><span class="o">.</span><span class="n">PrintMeshInfo</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">flag</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

<span class="k">if</span><span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">MeshConverged</span> <span class="ow">and</span> <span class="n">flag</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh converged and optimal&quot;</span><span class="p">)</span>
<span class="k">elif</span><span class="p">(</span><span class="n">flag</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal but mesh not converged&quot;</span><span class="p">)</span>
<span class="k">elif</span><span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">MeshConverged</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh converged, but not optimal and may not satisfy all non-dynamic constraints&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try Again&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/PhaseMeshPrint.PNG"><img alt="../_images/PhaseMeshPrint.PNG" src="../_images/PhaseMeshPrint.PNG" style="width: 60%;" /></a>
</section>
<section id="optimal-control-problem">
<h2>Optimal Control Problem<a class="headerlink" href="#optimal-control-problem" title="Permalink to this heading">#</a></h2>
<p>Adaptive mesh refinement can also be enabled for multi-phase <code class="code docutils literal notranslate"><span class="pre">OptimalControlProblem</span></code> objects as well.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ocp</span>  <span class="o">=</span> <span class="n">oc</span><span class="o">.</span><span class="n">OptimalControlProblem</span><span class="p">()</span>

<span class="n">ocp</span><span class="o">.</span><span class="n">addPhase</span><span class="p">(</span><span class="n">phase1</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">addPhase</span><span class="p">(</span><span class="n">phase2</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">addPhase</span><span class="p">(</span><span class="n">phase3</span><span class="p">)</span>

<span class="n">EnableAdaptive</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">ApplyToAllPhases</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1">## Turn on adaptive mesh for the ocp and enable it for all phases CURRENTLY in the ocp</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">setAdaptiveMesh</span><span class="p">(</span><span class="n">EnableAdaptive</span><span class="p">,</span><span class="n">ApplyToAllPhases</span><span class="p">)</span>

<span class="c1">## Turn it on for the ocp, but not the phases: allows you selectively enable</span>
<span class="c1">## which phases are going to have adaptive mesh</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">setAdaptiveMesh</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>

<span class="n">ocp</span><span class="o">.</span><span class="n">setAdaptiveMesh</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># Equivalent to ocp.setAdaptiveMesh(False,False)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">setAdaptiveMesh</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Equivalent to ocp.setAdaptiveMesh(True,True)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">setAdaptiveMesh</span><span class="p">()</span>      <span class="c1"># Equivalent to ocp.setAdaptiveMesh(True,True)</span>
</pre></div>
</div>
<p>Similarly, we can apply uniform settings/parameters to the mesh refinement process on each phase as shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ocp</span><span class="o">.</span><span class="n">setMeshTol</span><span class="p">(</span><span class="mf">1.0e-7</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">setMeshErrorEstimator</span><span class="p">(</span><span class="s1">&#39;integrator&#39;</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">setMeshErrorCriteria</span><span class="p">(</span><span class="s1">&#39;endtoend&#39;</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">setMeshRedFactor</span><span class="p">(</span><span class="mf">.5</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">setMeshErrFactor</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
<span class="c1"># etc..</span>

<span class="c1">## Equivalent to</span>
<span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">ocp</span><span class="o">.</span><span class="n">Phases</span><span class="p">:</span>
    <span class="n">phase</span><span class="o">.</span><span class="n">setMeshTol</span><span class="p">(</span><span class="mf">1.0e-7</span><span class="p">)</span>
    <span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrorEstimator</span><span class="p">(</span><span class="s1">&#39;integrator&#39;</span><span class="p">)</span>
    <span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrorCriteria</span><span class="p">(</span><span class="s1">&#39;endtoend&#39;</span><span class="p">)</span>
    <span class="n">phase</span><span class="o">.</span><span class="n">setMeshRedFactor</span><span class="p">(</span><span class="mf">.5</span><span class="p">)</span>
    <span class="n">phase</span><span class="o">.</span><span class="n">setMeshErrFactor</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Additionally, it is not required that all phases have the same tolerances or parameters. You may set them
each individually, or even disable adaptive mesh refinement on some phases as well.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ocp</span><span class="o">.</span><span class="n">Phase</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">setMeshErrorEstimator</span><span class="p">(</span><span class="s1">&#39;endtoend&#39;</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">Phase</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">setMeshTol</span><span class="p">(</span><span class="mf">1.0e-9</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">Phase</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">setAdaptiveMesh</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>However,the maximum number of mesh iterations and the console printing are controlled only by the <code class="code docutils literal notranslate"><span class="pre">ocp</span></code> object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ocp</span><span class="o">.</span><span class="n">setMaxMeshIters</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">PrintMeshInfo</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># fine, but ignored</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">Phase</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">setMaxMeshIters</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ocp</span><span class="o">.</span><span class="n">Phase</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">PrintMeshInfo</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>With adaptive mesh refinement enabled, we continually solve/optimize, the entire problem until
all constituent phases with adaptive mesh refinement enabled have converged or the maximum number of mesh iterates is reached.
Once any one of the phases is converged, we do not modify the mesh spacing or number of segments of that phase
on subsequent mesh iterations so long as it continues to satisfy the error tolerances.
At each mesh iteration, additional information (see figure) pertaining to the progress of the refinement process will be printed along with the normal optimizer output.
The convergence status of all phases (with adaptive mesh refinement enabled) can be checked using the <code class="code docutils literal notranslate"><span class="pre">.MeshConverged</span></code> field of the <code class="code docutils literal notranslate"><span class="pre">ocp</span></code>. Alternatively
you can also query the convergence status of the individual phases themselves.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># (Optional) Suppress optimizer output to only on print convergence status</span>
<span class="n">phase</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">PrintLevel</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">flag</span> <span class="o">=</span> <span class="n">ocp</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

<span class="k">if</span><span class="p">(</span><span class="n">ocp</span><span class="o">.</span><span class="n">MeshConverged</span> <span class="ow">and</span> <span class="n">flag</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Problem solved to optimality and all phase meshes converged&quot;</span><span class="p">)</span>

<span class="k">else</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">phase</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ocp</span><span class="o">.</span><span class="n">Phases</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> Converged??:&quot;</span><span class="p">,</span><span class="n">phase</span><span class="o">.</span><span class="n">MeshConverged</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/OcpMeshPrint.PNG"><img alt="../_images/OcpMeshPrint.PNG" src="../_images/OcpMeshPrint.PNG" style="width: 60%;" /></a>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>de Boor, C. (1973). Good approximation by splines with variable knots. In Spline Functions and Approximation Theory: Proceedings of the Symposium held at the University of Alberta, Edmonton May 29 to June 1, 1972 (pp. 57-72). Birkhauser Basel.</p></li>
<li><p>Russell, R. D., &amp; Christiansen, J. (1978). Adaptive mesh selection strategies for solving boundary value problems. SIAM Journal on Numerical Analysis, 15(1), 59-80.</p></li>
<li><p>T Ozimek, M., J Grebow, D., &amp; C Howell, K. (2010). A collocation approach for computing solar sail lunar pole-sitter orbits. The Open Aerospace Engineering Journal, 3(1).</p></li>
</ol>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="OptimalControlUtilites.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Optimal Control Utilities</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="PSIOPT.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">PSIOPT</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022-2023, UA ASRL
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Adaptive Mesh Refinement Tutorial</a><ul>
<li><a class="reference internal" href="#mathematical-background">Mathematical Background</a></li>
<li><a class="reference internal" href="#phase">Phase</a></li>
<li><a class="reference internal" href="#optimal-control-problem">Optimal Control Problem</a><ul>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>