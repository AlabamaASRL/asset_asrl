<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Optimal Control Problem Tutorial" href="OptimalControlProblem.html" /><link rel="prev" title="Integrator Tutorial" href="IntegratorGuide.html" />

    <!-- Generated with Sphinx 6.2.1 and Furo 2023.07.26 -->
        <title>Optimal Control Phase Tutorial - ASSET 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=369552022d0b975c8e74270ce6eabe0fb7978f24" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: red;
  --color-brand-content: #CC3333;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ASSET 0.2.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/ASSETLOGO.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ASSET 0.2.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="tutorials.html">Tutorials</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Install.html">Installing ASSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="VectorFunctionGuide.html">Vector Function Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ODEGuide.html">ODE Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="IntegratorGuide.html">Integrator Tutorial</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Optimal Control Phase Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptimalControlProblem.html">Optimal Control Problem Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="PSIOPT.html">PSIOPT</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutoMeshGuide.html">Adaptive Mesh Refinement Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptimalControlUtilites.html">Optimal Control Utilities</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../examples/examples.html">Examples</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Examples</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples/Delta3.html">Delta 3 Multi-phase GTO Transfer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ReentryExample.html">Space Shuttle Reentry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/CartPole.html">Cart-Pole Swing Up</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/HyperSensitive.html">Hyper-Sensitive Optimal Control Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/halo.html">Orbit Family Continuation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/zermelo.html">Zermelo’s Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/zermelolink.html">Multi-Phase Zermelo’s Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/MultiTarg.html">Multi-Spacecraft Optimization</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../python/python.html">Python Library Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Python Library Documentation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../python/asset.html">ASSET</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/optimalcontrol.html">Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/vectorfunctions.html">Vector Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/Astro.html">ASSET Astro Library</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="optimal-control-phase-tutorial">
<span id="phase-guide"></span><h1>Optimal Control Phase Tutorial<a class="headerlink" href="#optimal-control-phase-tutorial" title="Permalink to this heading">#</a></h1>
<p>Like many other optimal control packages, ASSET divides a large, potentially heterogeneous optimal control
problem into distinct phases. In ASSET, the dynamics along a phase of the trajectory are governed by one ODE and
discretized using a single transcription scheme. We may apply custom constraints and objectives to phases and optimize them by themselves, or
combine multiple phases and optimize them all simultaneously.</p>
<p>To construct a phase, we must first define an ODE using what
we have learned in previous sections on <a class="reference internal" href="VectorFunctionGuide.html#vectorfunction-guide"><span class="std std-ref">vector functions</span></a> and <a class="reference internal" href="ODEGuide.html#ode-guide"><span class="std std-ref">ODEs</span></a>. In this section
we will utilize the trivial ODE below as a reference while we discuss the phase API.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DummyODE</span><span class="p">(</span><span class="n">oc</span><span class="o">.</span><span class="n">ODEBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xv</span><span class="p">,</span><span class="n">uv</span><span class="p">,</span><span class="n">pv</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">oc</span><span class="o">.</span><span class="n">ODEArguments</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">uv</span><span class="p">,</span><span class="n">pv</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">XVec</span><span class="p">(),</span><span class="n">xv</span><span class="p">,</span><span class="n">uv</span><span class="p">,</span><span class="n">pv</span><span class="p">)</span>
</pre></div>
</div>
<section id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this heading">#</a></h2>
<p>Given some ASSET ODE, we can construct a phase object
using it’s <code class="code docutils literal notranslate"><span class="pre">.phase</span></code> method. At minimum, we must first specify the transcription mode for the phase dynamics as a string.
Here we have chosen, third order Legendre-Gauss-Lobatto collocation or <code class="code docutils literal notranslate"><span class="pre">'LGL3'</span></code>, which approximates the trajectory as piecewise cubic splines. We can also
choose from the 5th and 7th Order LGL methods, the trapezoidal method, or a central shooting scheme. In most
cases we suggest first trying the <code class="code docutils literal notranslate"><span class="pre">'LGL3'</span></code> scheme, however the 5th and 7th order methods may be superior for some applications.
Additionally, users should prefer the LGL collocation methods over the central shooting scheme
for almost all applications, as they are almost always significantly faster and more robust.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ode</span> <span class="o">=</span> <span class="n">DummyODE</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="s2">&quot;LGL3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can supply an initial guess to the <code class="code docutils literal notranslate"><span class="pre">phase</span></code> using the <code class="code docutils literal notranslate"><span class="pre">.setTraj</span></code> method.
The initial guess should be formatted as a python list where each element
is a full ODE input (ie: <span class="math notranslate nohighlight">\([\vec{X}_i,t_i,\vec{U}_i,\vec{P}]\)</span>) at each point in time along the trajectory.
Note, that this is the same format as the output of an <code class="code docutils literal notranslate"><span class="pre">intgrate_dense</span></code> call for the ODE’s integrator.
In most cases we will just pass in the initial guess
and specify the number of segments of the chosen transcription type we want to
use to discretize the dynamics. By default these will be interpolated from the initial guess to be evenly spaced in time.
Note that the number of segments does not have to match the number
of states in the initial guess, nor do the states in the initial guess have to be evenly spaced in time. However, you should
include enough states in the initial guess so that it can be re-interpolated with decent accuracy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># the format of the input trajectory</span>
<span class="k">for</span> <span class="n">XtUP</span> <span class="ow">in</span> <span class="n">InitialGuess</span><span class="p">:</span>
    <span class="n">XtUP</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># The state variables,X</span>
    <span class="n">XtUP</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>    <span class="c1"># The time,t</span>
    <span class="n">XtUP</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="c1"># The control variables,U</span>
    <span class="n">XtUP</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>   <span class="c1"># The ODE parameter,P</span>

<span class="c1">## 500 Segments evenly spaced over entire time interval</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setTraj</span><span class="p">(</span><span class="n">InitialGuess</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also manually specify the initial spacing for segments. This is done by passing a python list
<code class="code docutils literal notranslate"><span class="pre">SegBinSpacing</span></code> of length <code class="code docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;=2</span></code> specifying the spacing on the non-dimensional time interval 0-1
for groups of evenly spaced segments. We then pass another list, <code class="code docutils literal notranslate"><span class="pre">SegsPerBin</span></code>, of length <code class="code docutils literal notranslate"><span class="pre">n-1</span></code> specifying
an integer number of segments we want in each group. For example, we can replicate the behavior of the
default method as shown below. Alternatively, we could specify that we want to vary the density of
segments across the <code class="code docutils literal notranslate"><span class="pre">phase</span></code>. In most cases, the user’s first option should be to just evenly space segments over
the phase. One can also create a <code class="code docutils literal notranslate"><span class="pre">phase</span></code>, set the transcription method, and initial guess in the same
call as shown on the final line.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">## 500 Segments evenly spaced over entire time interval</span>
<span class="n">SegBinSpacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="n">SegsPerBin</span><span class="o">=</span>        <span class="p">[</span><span class="mi">500</span><span class="p">]</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setTraj</span><span class="p">(</span><span class="n">InitialGuess</span><span class="p">,</span><span class="n">SegBinSpacing</span><span class="p">,</span><span class="n">SegsPerBin</span><span class="p">)</span>

<span class="c1"># 300 segments spaced over first half of trajectory, 200 over last half</span>
<span class="n">SegBinSpacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.5</span> <span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="n">SegsPerBin</span>       <span class="o">=</span><span class="p">[</span> <span class="mi">300</span> <span class="p">,</span> <span class="mi">200</span><span class="p">]</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setTraj</span><span class="p">(</span><span class="n">InitialGuess</span><span class="p">,</span><span class="n">SegBinSpacing</span><span class="p">,</span><span class="n">SegsPerBin</span><span class="p">)</span>

<span class="c1">## create phase, set Transcription, IG, and number of segments</span>
<span class="n">phase</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="s2">&quot;LGL3&quot;</span><span class="p">,</span><span class="n">InitialGuess</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to specifying the transcription mode, we can also choose from several
different control parameterizations, using the <code class="code docutils literal notranslate"><span class="pre">.setControlMode</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Options: FirstOrderSpline,HighestOrderSpline,BlockConstant,NoSpline</span>
<span class="n">phase</span><span class="o">.</span><span class="n">setControlMode</span><span class="p">(</span><span class="s2">&quot;FirstOrderSpline&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, this is set to <code class="code docutils literal notranslate"><span class="pre">'FirstOrderSpline'</span></code>, which will ensure that the control history has smooth
first derivatives (if possible for the chosen transcription). This is typically sufficient to prevent control chattering in
the <code class="code docutils literal notranslate"><span class="pre">'LGL5'</span></code>, and <code class="code docutils literal notranslate"><span class="pre">'LGL7'</span></code> methods. We can also set the ControlMode to <code class="code docutils literal notranslate"><span class="pre">'HighestOrderSpline'</span></code> to enforce continuity
in all derivatives possible for a given transcription method. For <code class="code docutils literal notranslate"><span class="pre">'LGL5'</span></code>, the control is represented as a piecewise
quadratic function, so <code class="code docutils literal notranslate"><span class="pre">'FirstOrderSpline'</span></code> and <code class="code docutils literal notranslate"><span class="pre">'HighestOrderSpline'</span></code> are equivalent. For <code class="code docutils literal notranslate"><span class="pre">'LGL7'</span></code>, the control is represented
as a piecewise cubic function, therefore setting control mode to <code class="code docutils literal notranslate"><span class="pre">'HighestOrderSpline'</span></code> will ensures that this cubic function
has smooth first and second derivatives. For the <code class="code docutils literal notranslate"><span class="pre">'LGL3'</span></code>, <code class="code docutils literal notranslate"><span class="pre">'Trapezoidal'</span></code>,and <code class="code docutils literal notranslate"><span class="pre">'CentralShooting'</span></code> schemes, the control
history is piecewise-linear across a segment and does need any regularization, thus for those methods, <code class="code docutils literal notranslate"><span class="pre">'FirstOrderSpline'</span></code> and
<code class="code docutils literal notranslate"><span class="pre">'HighestOrderSpline'</span></code> have no effect.</p>
<p>Alternatively, for all methods, we can also specify that rather than having a smooth control history, we want to have a piecewise
constant control history with 1 unique control per segment. This can be specified by setting the control mode to <code class="code docutils literal notranslate"><span class="pre">'BlockConstant'</span></code>.
In our experience this control parameterization can be very robust and typically results in KKT matrices that are faster to factor.
The caveat is that special care must be taken when re-integrating converged solutions with an explicit integrator. This will be covered in a later section.</p>
<p>In addition to the state, time, control, and ODE parameter variables representing the trajectory, we may also add what we call “static parameters” to the <code class="code docutils literal notranslate"><span class="pre">phase</span></code>.
These are non-time varying variables that you might need to formulate a custom constraint and objective that are not needed by the dynamics.
Note that these are not the same as ODE parameters. We can add static parameters by simply specifying their initial values as shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">phase</span><span class="o">.</span><span class="n">setStaticParams</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>  <span class="c1"># add two static parameters initialized to 0</span>
</pre></div>
</div>
<div class="table-wrapper colwidths-given docutils container" id="id1">
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">List of Phase Transcription Options</span><a class="headerlink" href="#id1" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 25%" />
<col style="width: 20%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Integral Method</p></th>
<th class="head"><p>Control Representation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">'LGL3'</span></code></p></td>
<td><p>Third order Legendre Gauss Lobatto collocation.
Two states per segment.</p></td>
<td><p>Trapezoidal Rule</p></td>
<td><p>Piecewise-Linear (<code class="code docutils literal notranslate"><span class="pre">'FirstOrderSpline'</span></code>), Piecewise-Constant (<code class="code docutils literal notranslate"><span class="pre">'BlockConstant'</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">'LGL5'</span></code></p></td>
<td><p>Fifth order Legendre Gauss Lobatto collocation.
Three states per segment.</p></td>
<td><p>Simpson’s Rule</p></td>
<td><p>Quadratic-Spline (<code class="code docutils literal notranslate"><span class="pre">'FirstOrderSpline'</span></code>), Piecewise-Constant (<code class="code docutils literal notranslate"><span class="pre">'BlockConstant'</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">'LGL7'</span></code></p></td>
<td><p>Seventh order Legendre Gauss Lobatto collocation.
Four states per segment.</p></td>
<td><p>Unnamed fourth order quadrature method</p></td>
<td><p>Cubic-Spline (<code class="code docutils literal notranslate"><span class="pre">'FirstOrderSpline'</span></code>),
Natural-Cubic-Spline (<code class="code docutils literal notranslate"><span class="pre">'HighestOrderSpline'</span></code>),
Piecewise-Constant (<code class="code docutils literal notranslate"><span class="pre">'BlockConstant'</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">'Trapezoidal'</span></code></p></td>
<td><p>Trapezoidal collocation.
Two states per segment.</p></td>
<td><p>Trapezoidal Rule</p></td>
<td><p>Piecewise-Linear (<code class="code docutils literal notranslate"><span class="pre">'FirstOrderSpline'</span></code>), Piecewise-Constant (<code class="code docutils literal notranslate"><span class="pre">'BlockConstant'</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">'CentralShooting'</span></code></p></td>
<td><p>Adaptive Dormand Prince 8(7) central shooting method.
Two states per segment.</p></td>
<td><p>Trapezoidal Rule</p></td>
<td><p>Piecewise-Linear (<code class="code docutils literal notranslate"><span class="pre">'FirstOrderSpline'</span></code>), Piecewise-Constant (<code class="code docutils literal notranslate"><span class="pre">'BlockConstant'</span></code>)</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="constraints-and-objectives">
<span id="conobj-guide"></span><h2>Constraints and Objectives<a class="headerlink" href="#constraints-and-objectives" title="Permalink to this heading">#</a></h2>
<p>Before discussing the interface for adding different types of constraints, it is helpful to briefly overview how we represent a phases’s variables
when formulating an optimization problem. In general we partition a trajectory with <span class="math notranslate nohighlight">\(n\)</span> states into each time-varying portion <span class="math notranslate nohighlight">\(\vec{V}_i\)</span> of the ODE’s inputs followed by the
ODE parameters, <span class="math notranslate nohighlight">\(\vec{P}\)</span>, and the phase’s static parameters, <span class="math notranslate nohighlight">\(\vec{S}\)</span>, below.</p>
<div class="math-wrapper docutils container" id="eq-1">
<span id="equation-eq-1"></span><div class="math notranslate nohighlight" id="eq-1">
<span id="equation-eq-1"></span><span class="eqno">(1)<a class="headerlink" href="#eq-1" title="Permalink to this equation">#</a></span>\[\begin{split}\vec{x} = \begin{bmatrix}
           \vec{V}_1     \\
           \vec{V}_2     \\
           \vdots        \\
           \vec{V}_{n-1} \\
           \vec{V_n}     \\
           \vec{P}       \\
           \vec{S}       \\
          \end{bmatrix}
 \quad \quad \text{where} \quad \vec{V}_i = [\vec{X}_i,t_i,\vec{U}_i]\end{split}\]</div>
</div>
<p>The transcription defect constraints, and segment mesh spacing constraints are formulated automatically by the phase object, and users should not
attempt to formulate them on their own. Every other constraint and objective must be specified by the user, in terms of the discrete representation of the trajectory. To simplify this process,
and provide an interface that is invariant to the number of segments, <code class="code docutils literal notranslate"><span class="pre">phase</span></code> only allows you to write constraints/objectives that gather inputs from certain “phase regions” in the total variables
vector. A complete list of the currently allowed phase regions is listed below and we will discuss how you can use them in the next section.</p>
<div class="table-wrapper colwidths-given docutils container" id="id2">
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Phase Regions</span><a class="headerlink" href="#id2" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 50%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Phase Region</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Input Order</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">Front</span></code>, or <code class="code docutils literal notranslate"><span class="pre">First</span></code></p></td>
<td><p>Applied to first time-varying-input, the ODE parameters and the phase’s static parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\vec{f}([\vec{V}_1,\vec{P},\vec{S}])\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">Back</span></code>,or <code class="code docutils literal notranslate"><span class="pre">Last</span></code></p></td>
<td><p>Applied to last time-varying-input, the ODE parameters and the phase’s static parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\vec{f}([\vec{V}_n,\vec{P},\vec{S}])\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">Path</span></code></p></td>
<td><p>Applied to every time-varying-input, the ODE parameters and the phase’s static parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\vec{f}([\vec{V}_i,\vec{P},\vec{S}]),\; i = 1\ldots n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">InnerPath</span></code></p></td>
<td><p>Applied to every time-varying-input (excluding the first and last), the ODE parameters and the phase’s static parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\vec{f}([\vec{V}_i,\vec{P},\vec{S}]),\; i = 2\ldots n-1\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">FrontandBack</span></code>, or <code class="code docutils literal notranslate"><span class="pre">FirstandLast</span></code></p></td>
<td><p>Applied to the first and last time-varying-inputs, the ODE parameters and the phase’s static parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\vec{f}([\vec{V}_1,\vec{V}_n,\vec{P},\vec{S}])\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">PairWisePath</span></code></p></td>
<td><p>Applied to every pair of adjacent time-varying-inputs, the ODE parameters and the phase’s static parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\vec{f}([\vec{V}_i,\vec{V}_{i+1},\vec{P},\vec{S}]),\; i = 1\ldots n-1\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">ODEParams</span></code></p></td>
<td><p>Applied only to the ODE parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\vec{f}([\vec{P}])\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">StaticParams</span></code></p></td>
<td><p>Applied only to the phase’s static parameters.</p></td>
<td><p><span class="math notranslate nohighlight">\(\vec{f}([\vec{S}])\)</span></p></td>
</tr>
</tbody>
</table>
</div>
<section id="equality-constraints">
<h3>Equality Constraints<a class="headerlink" href="#equality-constraints" title="Permalink to this heading">#</a></h3>
<p>Equality constraints of the form <span class="math notranslate nohighlight">\(\vec{h}(\vec{x}) = \vec{0}\)</span>, can be added to a phase using the <code class="code docutils literal notranslate"><span class="pre">.addEqualCon</span></code> method. First we specify
the phase region to which the constraint will be applied followed by the equality
constraint itself (an ASSET vector (or scalar) function). Next, we specify which of the indices of time-varying input variables at the phase region,
as well as any ODE parameters and phase’s static parameters we wish to forward to the function. In the trivial example below, we are adding a
constraint that enforces that the first time-varying inputs in the trajectory and all of the ODE parameters and static parameters should be equal to zero.
Custom constraints must be written such that the inputs consist of the time-varying inputs (if any), followed by the ODE parameters (if any), and then the static
parameters (if any). However, the variables inside of a particular variable group (ex:<code class="code docutils literal notranslate"><span class="pre">XtUVars</span></code>) can be specified in any order so long as it is consistent
with how you have defined your constraint function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;First&quot;</span>

<span class="k">def</span> <span class="nf">AnEqualCon</span><span class="p">():</span>
    <span class="n">XtU_OP_SP</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">XtU_OP_SP</span>

<span class="n">XtUVars</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># indices of state, time, and control variables at the PhaseRegion we want to forward to our function</span>
<span class="n">OPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># indices of the ODE Parameters (indexed from 0) we want to forward to our function</span>
<span class="n">SPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># indices of the phase Static Parameters (indexed from 0) we want to forward to our function</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">AnEqualCon</span><span class="p">(),</span><span class="n">XtUVars</span><span class="p">,</span><span class="n">OPVars</span><span class="p">,</span><span class="n">SPVars</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It should be further emphasized that you do not have to include every variable in a phase region for every constraint.</p>
</div>
<p>For example, below we add a constraint involving the second and third state variables from the
last time-varying state in the trajectory, as well as the first ODE parameter and second static parameter.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;Last&quot;</span>

<span class="c1">## Only need second and third state variables, the first ode parameter, and the second static parameter</span>
<span class="k">def</span> <span class="nf">AnotherEqualCon</span><span class="p">():</span>
    <span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">op0</span><span class="p">,</span><span class="n">sp1</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">vf</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">op0</span><span class="o">/</span><span class="n">sp1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">42.0</span>

<span class="n">XtUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># indices of state, time, and control variables at the PhaseRegion we want to forward to our function</span>
<span class="n">OPVars</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># indcices of the ODE Parameters (indexed from 0) we want to forward to our function</span>
<span class="n">SPVars</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="c1"># indcices of the phase Static Parameters (indexed from 0) we want to forward to our function</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">AnotherEqualCon</span><span class="p">(),</span><span class="n">XtUVars</span><span class="p">,</span><span class="n">OPVars</span><span class="p">,</span><span class="n">SPVars</span><span class="p">)</span>
</pre></div>
</div>
<p>Furthermore, when variables from only a single grouping are needed we do not have to pass the others as arguments, as illustrated in the three
examples below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">XtUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>  <span class="c1"># Just the controls and nothing else</span>
<span class="c1"># enforce unit norm of all control vectors</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="n">XtUVars</span><span class="p">,[],[])</span>
<span class="c1"># same as above</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="n">XtUVars</span><span class="p">)</span>


<span class="n">OPVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Just the ODEParam</span>
<span class="c1">#Enforce Square of first ODE param = 4</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;ODEParams&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">4.0</span><span class="p">,[],</span><span class="n">OPVars</span><span class="p">,[])</span>
<span class="c1"># same as above</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;ODEParams&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">4.0</span><span class="p">,</span><span class="n">OPVars</span><span class="p">)</span>


<span class="n">SPVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Just the static params</span>
<span class="c1">#Enforce sum of static params = 2</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;StaticParams&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">,[],[],</span><span class="n">SPVars</span><span class="p">)</span>
<span class="c1"># same as above</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;StaticParams&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">,</span><span class="n">SPVars</span><span class="p">)</span>
</pre></div>
</div>
<p>The previous examples only illustrate the usage of the phase regions that take at most one time-varying input; however, phase regions <code class="code docutils literal notranslate"><span class="pre">&quot;FrontandBack&quot;</span></code>, and
<code class="code docutils literal notranslate"><span class="pre">&quot;PairWisePath&quot;</span></code> take two time-varying inputs. An example of how to use a two input phase region is shown below. Here we are constraining that the first and last states should be equal
and that the difference between the last and first time of the phase should be equal to a static parameter that we have added to the phase. We only specify which time-varying variables
we want once. The same set is gathered from the first state and last state and forwarded to the function, followed by any ODE parameters (none in this case)
and static parameters (just the first in this case).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">FrontBackEqCon</span><span class="p">():</span>
    <span class="n">X_0</span><span class="p">,</span><span class="n">t_0</span><span class="p">,</span><span class="n">X_f</span><span class="p">,</span><span class="n">t_f</span><span class="p">,</span><span class="n">sp0</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">13</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>

    <span class="n">eq1</span> <span class="o">=</span> <span class="n">X_0</span><span class="o">-</span><span class="n">X_f</span>
    <span class="n">eq2</span> <span class="o">=</span> <span class="n">t_f</span><span class="o">-</span><span class="n">t_0</span> <span class="o">-</span> <span class="n">sp0</span>
    <span class="k">return</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span><span class="n">eq2</span><span class="p">)</span>


<span class="n">XtUVars</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>  <span class="c1"># indices of all states and time</span>
<span class="n">SPVars</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># first static parameter</span>
<span class="c1"># Constrain first and last states to be equal and</span>
<span class="c1"># constrain Delta Time over the phase (tf-t0) to be equal to the first static parameter</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;FirstandLast&quot;</span><span class="p">,</span><span class="n">FrontBackEqCon</span><span class="p">(),</span><span class="n">XtUVars</span><span class="p">,[],</span><span class="n">SPVars</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to the general methods of adding equality constraints illustrated in the previous examples, there are several additional methods to simplify the
definition of commonly occurring types of constraints. By far the most commonly used is the <code class="code docutils literal notranslate"><span class="pre">.addBoundaryValue</span></code> method, which simply adds a constraint that the specified
variables should be equal to some vector of constants (can be a 1-D numpy array or a python list). This method is typically used to
enforce known initial and terminal conditions on a phase.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">XtUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">Values</span>  <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">,</span><span class="mf">42.0</span><span class="p">]</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addBoundaryValue</span><span class="p">(</span><span class="s2">&quot;First&quot;</span><span class="p">,</span><span class="n">XtUVars</span><span class="p">,</span><span class="n">Values</span><span class="p">)</span>

<span class="n">OPVars</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Values</span>  <span class="o">=</span> <span class="p">[</span><span class="mf">10.034</span><span class="p">]</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addBoundaryValue</span><span class="p">(</span><span class="s2">&quot;ODEParams&quot;</span><span class="p">,</span><span class="n">OPVars</span><span class="p">,</span><span class="n">Values</span><span class="p">)</span>

<span class="n">SPVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Values</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">4.0</span><span class="p">])</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addBoundaryValue</span><span class="p">(</span><span class="s2">&quot;StaticParams&quot;</span><span class="p">,</span><span class="n">SPVars</span><span class="p">,</span><span class="n">Values</span><span class="p">)</span>
</pre></div>
</div>
<p>Additionally, you can also use the <code class="code docutils literal notranslate"><span class="pre">addDeltaVarEqualCon</span></code> method
to constrain changes in variables from the <code class="code docutils literal notranslate"><span class="pre">&quot;First&quot;</span></code> to <code class="code docutils literal notranslate"><span class="pre">&quot;Last&quot;</span></code> phase regions to a specified value. This could, for example,
be used to enforce a fixed duration for the phase by supplying the index for time (<code class="code docutils literal notranslate"><span class="pre">&quot;6&quot;</span></code> in this case). However, constraining the delta time is
so common that we also provide the <code class="code docutils literal notranslate"><span class="pre">addDeltaTimeEqualCon</span></code> method to do just that.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Constrain change in 0th state variable from first to last state to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addDeltaVarEqualCon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="c1"># This does the same as the following</span>

<span class="n">DeltaEqualCon</span><span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Args</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;FirstandLast&quot;</span><span class="p">,</span><span class="n">DeltaEqualCon</span><span class="p">,[</span><span class="mi">0</span><span class="p">])</span>


<span class="c1">## These do the same thing, constraining the elapsed time over the phase to be = 3.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addDeltaVarEqualCon</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addDeltaTimeEqualCon</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span> <span class="c1">#Time is special and has its own named method</span>

<span class="c1"># Both are equivalent to the following</span>
<span class="n">DeltaEqualCon</span><span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Args</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="mf">3.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;FirstandLast&quot;</span><span class="p">,</span><span class="n">DeltaEqualCon</span><span class="p">,[</span><span class="mi">6</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="inequality-constraints">
<h3>Inequality Constraints<a class="headerlink" href="#inequality-constraints" title="Permalink to this heading">#</a></h3>
<p>Adding general inequality constraints, using <code class="code docutils literal notranslate"><span class="pre">.addInequalCon</span></code>, works exactly the same as it did for <code class="code docutils literal notranslate"><span class="pre">.addEqualCon</span></code>. The only difference
is that our functions should be constraints of the form <span class="math notranslate nohighlight">\(\vec{g}(\vec{x}) \leq \vec{0}\)</span>. In other words, we assume that our function is in the feasible region whenever
its value is negative. For example, if we wanted to add a constraint specifying that all of the initial time-varying input variables, ODE parameters, and the phase’s static
parameters should be positive, we could implement that as shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;First&quot;</span>

<span class="k">def</span> <span class="nf">AnInequalCon</span><span class="p">():</span>
    <span class="n">XtU_OP_SP</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">XtU_OP_SP</span>

<span class="n">XtUVars</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># indices of state, time, and control variables at the PhaseRegion we want to forward to our function</span>
<span class="n">OPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># indices of the ODE Parameters (indexed from 0) we want to forward to our function</span>
<span class="n">SPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># indices of the phase Static Parameters (indexed from 0) we want to forward to our function</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addInequalCon</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">AnInequalCon</span><span class="p">(),</span><span class="n">XtUVars</span><span class="p">,</span><span class="n">OPVars</span><span class="p">,</span><span class="n">SPVars</span><span class="p">)</span>

<span class="c1"># Other signatures follow the same rules as covered for addEqualCon</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addInequalCon</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span> <span class="n">Args</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addInequalCon</span><span class="p">(</span><span class="s2">&quot;Back&quot;</span><span class="p">,</span>  <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">squared_norm</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addInequalCon</span><span class="p">(</span><span class="s2">&quot;StaticParams&quot;</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">Args</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>However, it can be somewhat cumbersome to write many of the types of inequality constraints that you will encounter using this generalized method, thus
we offer many simplified alternatives which we now discuss.</p>
<p>The simplest type of inequality constraint we can apply are bounds on the variables. These can be added using the <code class="code docutils literal notranslate"><span class="pre">.addLower/Upper/LUVarBounds</span></code> methods as
shown below, these can be applied to any of the single time-varying input phase regions or the parameters. For any method, we can also specify a positive scale factor that will be
applied to the final bounding function. This can help scale an ill-conditioned bound but will not change the meaning of the constraint.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add lower bound to the 7th state,time,control variable</span>
<span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;Back&quot;</span>
<span class="n">VarIndex</span>    <span class="o">=</span> <span class="mi">7</span>
<span class="n">LowerBound</span>  <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">Scale</span>       <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># strictly positive scale factor</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addLowerVarBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIndex</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addLowerVarBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIndex</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">)</span>


<span class="c1"># Add upper bound to the 7th state,time,control variable</span>
<span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;Back&quot;</span>
<span class="n">VarIndex</span>    <span class="o">=</span> <span class="mi">7</span>
<span class="n">UpperBound</span>  <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">Scale</span>       <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># strictly positive scale factor</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addUpperVarBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIndex</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addUpperVarBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIndex</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">)</span>


<span class="c1">## Add Both Lower and Upper Bounds at same time</span>
<span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;Back&quot;</span>
<span class="n">VarIndex</span>    <span class="o">=</span> <span class="mi">7</span>
<span class="n">LowerBound</span>  <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">UpperBound</span>  <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">Scale</span>       <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># strictly positive scale factor for both bounds</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addLUVarBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIndex</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addLUVarBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIndex</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">)</span>

<span class="c1"># Also works for the parameter variables</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addLUVarBound</span><span class="p">(</span><span class="s2">&quot;StaticParams&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Violations are now of order one</span>
<span class="n">Scale</span> <span class="o">=</span> <span class="mf">10000.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addUpperVarBound</span><span class="p">(</span><span class="s2">&quot;ODEParams&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">10000.0</span><span class="p">,</span> <span class="n">Scale</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to placing bounds on variables, you can also place bounds on the outputs of ScalarFunctions of the variables. This
is accomplished using the <code class="code docutils literal notranslate"><span class="pre">.addLower/Upper/LUFuncBound</span></code> methods as shown below. In this example we are showing various ways to bound the norm
of all of the controls (variables <code class="code docutils literal notranslate"><span class="pre">[7,8,9]</span></code> for this contrived ODE) to be between 0 and 1.0.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">## Upper bound on the norm of the controls</span>
<span class="n">PhaseRegion</span> <span class="o">=</span><span class="s2">&quot;Path&quot;</span>
<span class="n">ScalarFunc</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">XTUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">UpperBound</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addUpperFuncBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">ScalarFunc</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addUpperFuncBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">ScalarFunc</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">)</span>


<span class="c1">## Lower bound on the norm of the controls</span>
<span class="n">PhaseRegion</span> <span class="o">=</span><span class="s2">&quot;Path&quot;</span>
<span class="n">ScalarFunc</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">XTUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">LowerBound</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addLowerFuncBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">ScalarFunc</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addLowerFuncBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">ScalarFunc</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">)</span>


<span class="c1">## Lower and Upper on squared norm at the same time</span>
<span class="n">PhaseRegion</span> <span class="o">=</span><span class="s2">&quot;Path&quot;</span>
<span class="n">ScalarFunc</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">squared_norm</span><span class="p">()</span>
<span class="n">XTUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">LowerBound</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">UpperBound</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addLUFuncBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">ScalarFunc</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addLUFuncBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">ScalarFunc</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">)</span>
</pre></div>
</div>
<p>These methods can be applied to any ScalarFunction you wish to bound; however, the examples above
that bound the <code class="code docutils literal notranslate"><span class="pre">norm</span></code> or <code class="code docutils literal notranslate"><span class="pre">squared_norm</span></code> are so common that we also provide methods that do just that. Below, we use the <code class="code docutils literal notranslate"><span class="pre">.addLower/Upper/NormBound</span></code>
and <code class="code docutils literal notranslate"><span class="pre">.addLower/Upper/SquaredNormBound</span></code> methods that accomplish the same tasks as the previous code block.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">## Upper bound on the norm of the controls</span>
<span class="n">PhaseRegion</span> <span class="o">=</span><span class="s2">&quot;Path&quot;</span>
<span class="n">XTUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">UpperBound</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addUpperNormBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addUpperNormBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">)</span>


<span class="c1">## Lower bound on the norm of the controls</span>
<span class="n">PhaseRegion</span> <span class="o">=</span><span class="s2">&quot;Path&quot;</span>
<span class="n">XTUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">LowerBound</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addLowerNormBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addLowerNormBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">)</span>


<span class="c1">## Both at the same time</span>
<span class="n">PhaseRegion</span> <span class="o">=</span><span class="s2">&quot;Path&quot;</span>
<span class="n">XTUVars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">LowerBound</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">UpperBound</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addLUSquaredNormBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addLUSquaredNormBound</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">XTUVars</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">UpperBound</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to how we can place equality constraints on the change in a variable from the beginning to end of
a phase, we can also place bounds on the changes in variables as shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">VarIdx</span>     <span class="o">=</span> <span class="mi">0</span>
<span class="n">LowerBound</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">Scale</span>      <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addLowerDeltaVarBound</span><span class="p">(</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addLowerDeltaVarBound</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">)</span>


<span class="n">VarIdx</span>     <span class="o">=</span> <span class="mi">0</span>
<span class="n">UpperBound</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">Scale</span>      <span class="o">=</span> <span class="mf">1.0</span>


<span class="n">phase</span><span class="o">.</span><span class="n">addUpperDeltaVarBound</span><span class="p">(</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1"># If no scale factor is supplied it is assumed to be = 1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addUpperDeltaVarBound</span><span class="p">(</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">)</span>


<span class="c1"># Time is special, we can use addLower/UpperDeltaTimeBound instead</span>
<span class="n">LowerBound</span> <span class="o">=</span> <span class="mf">.5</span>
<span class="n">UpperBound</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">Scale</span>      <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addLowerDeltaTimeBound</span><span class="p">(</span><span class="n">LowerBound</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addUpperDeltaTimeBound</span><span class="p">(</span><span class="n">UpperBound</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="state-objectives">
<h3>State Objectives<a class="headerlink" href="#state-objectives" title="Permalink to this heading">#</a></h3>
<p>The simplest type of objective function that we can add to a phase is a state objective. It is a ScalarFunction that we
wish to directly minimize that takes some or all of the variables at a phase region. Note, if you are trying to maximize something you should
multiply it’s value by a negative constant, as ASSET interprets all objective values as values to be minimized. Generalized state objectives can be added to a phase using the <code class="code docutils literal notranslate"><span class="pre">.addStateObjective</span></code> function as shown below. The same rules governing
<code class="code docutils literal notranslate"><span class="pre">.addEqualCon</span></code>, and <code class="code docutils literal notranslate"><span class="pre">.addInequalCon</span></code> apply here to all possible permutations to the inputs of <code class="code docutils literal notranslate"><span class="pre">.addStateObjective</span></code>. The only exception being that the function
must be an ASSET ScalarFunction.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">AStateObjective</span><span class="p">():</span>
<span class="n">XtU_OP_SP</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="k">return</span> <span class="n">XtU_OP_SP</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>  <span class="c1">## An Asset Scalar Function</span>

<span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;Back&quot;</span>
<span class="n">XtUVars</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># indices of state, time, and control variables at the PhaseRegion we want to forward to our function</span>
<span class="n">OPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># indices of the ODE Parameters (indexed from 0) we want to forward to our function</span>
<span class="n">SPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># indices of the phase Static Parameters (indexed from 0) we want to forward to our function</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addStateObjective</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">AStateObjective</span><span class="p">(),</span><span class="n">XtUVars</span><span class="p">,</span><span class="n">OPVars</span><span class="p">,</span><span class="n">SPVars</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to the general methods, we also provide two more specialized methods that encompass two of the most common types of state objectives.</p>
<p>The first is the <code class="code docutils literal notranslate"><span class="pre">.addValueObjective</span></code> method which simply adds an objective function specifying that we want to minimize the value of one the variables
at a specified phase region multiplied by a scalar factor. To maximize the value, make the scale factor negative.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Minimize the final value of XtUVar 5</span>
<span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;Last&quot;</span>
<span class="n">VarIdx</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addValueObjective</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>


<span class="c1"># Maximize the initial value of XtUVar 0</span>
<span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;First&quot;</span>
<span class="n">VarIdx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Scale</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>  <span class="c1">## Negative scale factors to maximize!!!</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addValueObjective</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>


<span class="c1"># Minimize the Static Param 0</span>
<span class="n">PhaseRegion</span> <span class="o">=</span> <span class="s2">&quot;StaticParams&quot;</span>
<span class="n">VarIdx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Scale</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addValueObjective</span><span class="p">(</span><span class="n">PhaseRegion</span><span class="p">,</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
</pre></div>
</div>
<p>The second is the <code class="code docutils literal notranslate"><span class="pre">.addDeltaVarObjective</span></code> which adds an objective to minimize the change in the value of some variable across the phase multiplied by
a scale factor. As before, to maximize the change, make the scale factor negative.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Minimize change in XtUVar 2 across the phase ie: x2_f - x2_0</span>
<span class="n">VarIdx</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Scale</span>  <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addDeltaVarObjective</span><span class="p">(</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>


<span class="c1"># Maximize change in XtUVar 4 across the phase ie: x4_f - x4_0</span>
<span class="n">VarIdx</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">Scale</span>  <span class="o">=</span> <span class="o">-</span><span class="mf">100.0</span>  <span class="c1"># Negative scale factor to maximize</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addDeltaVarObjective</span><span class="p">(</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>

<span class="c1"># Minimize the duration of the phase : tf-t0</span>
<span class="n">VarIdx</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Index of time</span>
<span class="n">Scale</span>  <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addDeltaVarObjective</span><span class="p">(</span><span class="n">VarIdx</span><span class="p">,</span><span class="n">Scale</span><span class="p">)</span>
<span class="c1">## Time is special and has its own named method that does the same as above</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addDeltaTimeObjective</span><span class="p">(</span><span class="n">Scale</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="integral-objectives">
<h3>Integral Objectives<a class="headerlink" href="#integral-objectives" title="Permalink to this heading">#</a></h3>
<p>The other common type of objective functions that we can add to a <code class="code docutils literal notranslate"><span class="pre">phase</span></code> are integral objectives of the form.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\int_{t_0}^{t_f} f([\vec{X}(t),t,\vec{U}(t),\vec{P},\vec{S}]) dt\]</div>
</div>
<p>To add an integral objective, we provide a scalar integrand function to the <code class="code docutils literal notranslate"><span class="pre">phase</span></code> using the <code class="code docutils literal notranslate"><span class="pre">.addIntegralObjective</span></code> method.
The quadrature method used to approximate the integral will be depend on the current transcription type and are given in table 1.
When adding integral objectives as shown below, we only need to provide the integrand function and the
indices from the various variable groupings we want to forward to the integrand (ie: no phase region is needed).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">AnIntegrand</span><span class="p">():</span>
    <span class="n">XtU_OP_SP</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">XtU_OP_SP</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>  <span class="c1">## An Asset Scalar Function</span>

<span class="n">XtUVars</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># indices of state, time, and control variables at the PhaseRegion we want to forward to our function</span>
<span class="n">OPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># indices of the ODE Parameters (indexed from 0) we want to forward to our function</span>
<span class="n">SPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># indices of the phase Static Parameters (indexed from 0) we want to forward to our function</span>


<span class="c1"># Signature if variables of all types are needed by integrand</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addIntegralObjective</span><span class="p">(</span><span class="n">AnIntegrand</span><span class="p">(),</span><span class="n">XtUVars</span><span class="p">,</span><span class="n">OPVars</span><span class="p">,</span><span class="n">SPVars</span><span class="p">)</span>

<span class="c1"># Signature if only state,time, and control variables needed by integrand</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addIntegralObjective</span><span class="p">(</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(),[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>

<span class="c1"># All integrands are minimized, so to maximize, multiply by negative number</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addIntegralObjective</span><span class="p">(</span><span class="o">-</span><span class="mf">10.0</span><span class="o">*</span><span class="n">Args</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="integral-parameter-functions">
<h3>Integral Parameter Functions<a class="headerlink" href="#integral-parameter-functions" title="Permalink to this heading">#</a></h3>
<p>The final class of functions that we can add to a phase are what we call “integral parameter functions”. These are used along with static parameters
to facilitate integral constraints on a <code class="code docutils literal notranslate"><span class="pre">phase</span></code>. An integral parameter function is a special equality constraint of the form.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\int_{t_0}^{t_f} f([\vec{X}(t),t,\vec{U}(t),\vec{P},\vec{S}_{\not k}]) dt - s_k = 0\]</div>
</div>
<p>Essentially, this constraint will force the value of one of the static parameters to be equal to the integral of a user specified function.
One can then place constraints on this static parameter using any of the previously discussed methods.
Adding in an integral parameter function, using <code class="code docutils literal notranslate"><span class="pre">.addIntegralParamFunction</span></code> works essentially the same as <code class="code docutils literal notranslate"><span class="pre">.addIntegralObjective</span></code>, except we also provide the index
of the static parameter the integral value will be assigned to as the last argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">AnIntegrand</span><span class="p">():</span>
    <span class="n">XtU_OP_SP</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">XtU_OP_SP</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>  <span class="c1">## An Asset Scalar Function</span>

<span class="n">XtUVars</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># indices of state, time, and control variables at the PhaseRegion we want to forward to our function</span>
<span class="n">OPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># indices of the ODE Parameters (indexed from 0) we want to forward to our function</span>
<span class="n">SPVars</span>  <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># indices of the phase Static Parameters (indexed from 0), NOT INCLUDING THE ONE WE ARE ASSIGNING THE INTEGRAL TOO</span>
<span class="n">IntSPVar</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Assign the value of the integral to the second static parameter</span>

<span class="c1"># Signature if variables of all types are needed by integrand</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addIntegralParamFunction</span><span class="p">(</span><span class="n">AnIntegrand</span><span class="p">(),</span><span class="n">XtUVars</span><span class="p">,</span><span class="n">OPVars</span><span class="p">,</span><span class="n">SPVars</span><span class="p">,</span><span class="n">IntSPVar</span><span class="p">)</span>

<span class="c1"># Signature if only state,time, and control variables needed by integrand</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addIntegralParamFunction</span><span class="p">(</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(),[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span><span class="n">IntSPVar</span><span class="p">)</span>

<span class="c1">## Now we can apply constraints to the integral by constraining the static param</span>
<span class="c1"># Ex: constrain the integral to be equal to 100.0</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addBoundaryValue</span><span class="p">(</span><span class="s2">&quot;StaticParams&quot;</span><span class="p">,[</span><span class="mi">1</span><span class="p">],[</span><span class="mf">100.0</span><span class="p">])</span>
</pre></div>
</div>
</section>
</section>
<section id="solving-and-optimizing">
<h2>Solving and Optimizing<a class="headerlink" href="#solving-and-optimizing" title="Permalink to this heading">#</a></h2>
<p>After constructing a phase, supplying an initial guess, and adding constraints/objectives, we can now use PSIOPT to solve or optimize
the trajectory. The settings of the optimizer can be manipulated through a reference to PSIOPT attached to the phase object. However, calls to
the optimizer are handled through the phase itself as shown below. Both of these topics are handled in more details in the section on <a class="reference internal" href="PSIOPT.html#psiopt-guide"><span class="std std-ref">PSIOPT</span></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">phase</span><span class="o">.</span><span class="n">optimizer</span> <span class="c1">## reference to this phases instance of psiopt</span>
<span class="n">phase</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">set_OptLSMode</span><span class="p">(</span><span class="s2">&quot;L1&quot;</span><span class="p">)</span>


<span class="c1">## Solve just the dynamics,equality, and inequality constraints</span>
<span class="n">flag</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c1">## Optimize objective subject to the dynamic,equality, and inequality constraints</span>
<span class="n">flag</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

<span class="c1">## Call solve to find feasible point, then optimize objective subject to the dynamic,equality, and inequality constraints</span>
<span class="n">flag</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">solve_optimize</span><span class="p">()</span>

<span class="c1">## Same as above but calls solve if the optimize call fails to fully converge</span>
<span class="n">flag</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">solve_optimize_solve</span><span class="p">()</span>
</pre></div>
</div>
<p>After finding a solution, we can retrieve the converged trajectory using the <code class="code docutils literal notranslate"><span class="pre">.returnTraj</span></code> method of the <code class="code docutils literal notranslate"><span class="pre">phase</span></code>.
Note the trajectory is returned as a python list where each element is a full-ode input (ie: <span class="math notranslate nohighlight">\([\vec{X}_i,t_i,\vec{U}_i,\vec{P}]\)</span>) at each point in time along the trajectory.
You may also return the trajectory in the form of an <code class="code docutils literal notranslate"><span class="pre">oc.LGLInterpTable</span></code> so that it can be sampled as a smooth function of time. See the section on <a class="reference internal" href="OptimalControlUtilites.html#lglinterptable-and-interpfunction"><span class="std std-ref">LGLInterpTable and InterpFunction</span></a> for more details.
If you added static parameters to the <code class="code docutils literal notranslate"><span class="pre">phase</span></code>, these can be retrieved using <code class="code docutils literal notranslate"><span class="pre">.returnStaticParams</span></code>. Finally, you can also retrieve an estimate for the co-states
of an optimal control problem AFTER it has been optimized. These could then be used as the initial guess to an indirect form of the same optimization problem.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Traj</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnTraj</span><span class="p">()</span>

<span class="c1">## Output trajectory has same format as input</span>
<span class="k">for</span> <span class="n">XtUP</span> <span class="ow">in</span> <span class="n">Traj</span><span class="p">:</span>
    <span class="n">XtUP</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># The state variables,X</span>
    <span class="n">XtUP</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>    <span class="c1"># The time,t</span>
    <span class="n">XtUP</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="c1"># The control variables,U</span>
    <span class="n">XtUP</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>   <span class="c1"># The ODE parameter,P</span>

<span class="n">Tab</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnTrajTable</span><span class="p">()</span>  <span class="c1">## As an LGL interp table</span>

<span class="n">StatParams</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnStaticParams</span><span class="p">()</span>

<span class="n">CostateTraj</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnCostateTraj</span><span class="p">()</span> <span class="c1">#</span>

<span class="k">for</span> <span class="n">Ct</span> <span class="ow">in</span> <span class="n">CostateTraj</span><span class="p">:</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="c1"># The Costates associated with X</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>   <span class="c1"># The time</span>
</pre></div>
</div>
<p>Additionally, should you want to refine the mesh spacing of the trajectory after a solution, it is not necessary to create an entirely new <code class="code docutils literal notranslate"><span class="pre">phase</span></code>.
Instead, you can use the <code class="code docutils literal notranslate"><span class="pre">.refineTraj</span></code> methods as shown below. The simplest form of refinement can be accomplished using the <code class="code docutils literal notranslate"><span class="pre">.refineTrajManual</span></code> methods. In general these work exactly
the same as the <code class="code docutils literal notranslate"><span class="pre">.setTraj</span></code> methods except they use the currently loaded trajectory to interpolate the new mesh.
The second option is the <code class="code docutils literal notranslate"><span class="pre">.refineTrajEqual</span></code> method, which will attempt to refine the trajectory such the estimated error across all segments is equal.
Fortunately, ASSET’s run-time scales basically linear in the number of segments, so it is often a viable strategy to just double or quadruple
(or more) the number of segments, re-optimize and call it a day. Beginning in version 0.1.0, we also now have a closed loop adaptive mesh refinement method that will automatically update
the spacing and number of segments to meet desired error tolerances. See the  <a class="reference internal" href="AutoMeshGuide.html#mesh-guide"><span class="std std-ref">Adaptive Mesh Refinement Tutorial</span></a> tutorial for more details.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">phase</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="c1"># optimize or solve initial mesh</span>


<span class="n">phase</span><span class="o">.</span><span class="n">refineTrajManual</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># remesh trajectory with 1000 evenly spaced segments</span>
<span class="n">phase</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="c1"># optimize or solve new mesh</span>

<span class="c1">## Manually Specify spacing</span>
<span class="c1"># 600 segments spaced over first half of trajectory, 400 over last half</span>
<span class="n">SegBinSpacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.5</span> <span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="n">SegsPerBin</span>       <span class="o">=</span><span class="p">[</span> <span class="mi">600</span> <span class="p">,</span> <span class="mi">400</span><span class="p">]</span>
<span class="n">phase</span><span class="o">.</span><span class="n">refineTrajManual</span><span class="p">(</span><span class="n">SegBinSpacing</span><span class="p">,</span><span class="n">SegsPerBin</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="c1"># optimize or solve new mesh</span>


<span class="c1">## Remesh with 1000 segments spaced to have approximately equal error per segment</span>
<span class="n">phase</span><span class="o">.</span><span class="n">refineTrajEqual</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="c1"># optimize or solve new mesh</span>

<span class="n">TrajRef</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnTraj</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="miscellaneous-topics">
<h2>Miscellaneous Topics<a class="headerlink" href="#miscellaneous-topics" title="Permalink to this heading">#</a></h2>
<section id="shooting-method">
<h3>Shooting Method<a class="headerlink" href="#shooting-method" title="Permalink to this heading">#</a></h3>
<p>When using the Central Shooting transcription, under the hood, a phase uses an integrator for the corresponding ODE to formulate the shooting constraints and its derivatives.
This <code class="code docutils literal notranslate"><span class="pre">integrator</span></code> is always configured to use the <code class="code docutils literal notranslate"><span class="pre">&quot;DOPRI87&quot;</span></code> integration scheme, but users can modify the tolerances as well as the minimum and
maximum step sizes of the integrator to improve performance or increase accuracy. Users can access this <code class="code docutils literal notranslate"><span class="pre">integrator</span></code> using the <code class="code docutils literal notranslate"><span class="pre">.integrator</span></code> field of the phase and then
modify its settings just as was shown in the <a class="reference internal" href="IntegratorGuide.html#integrator-guide"><span class="std std-ref">integrator tutorial</span></a>. Note that we set the default step size of the integrator attached to a phase to 0.1. For fastest performance
you should modify this to be something near what you anticipate the real average step size to be when integrating your ODE.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">phase</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="s2">&quot;CentralShooting&quot;</span><span class="p">)</span>

<span class="n">phase</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">setAbsTol</span><span class="p">(</span><span class="mf">1.0e-13</span><span class="p">)</span>  <span class="c1">## Modify tolerances of adaptive step size algorithm</span>

<span class="n">DefStep</span> <span class="o">=</span> <span class="mf">.05</span>
<span class="n">MinStep</span> <span class="o">=</span> <span class="mf">.00001</span>
<span class="n">MaxStep</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">setStepSizes</span><span class="p">(</span><span class="n">DefStep</span><span class="p">,</span><span class="n">MinStep</span><span class="p">,</span><span class="n">MaxStep</span><span class="p">)</span>  <span class="c1"># Modify default,minimum and maximum step sizes.</span>
</pre></div>
</div>
</section>
<section id="control-rate-constraints">
<h3>Control Rate Constraints<a class="headerlink" href="#control-rate-constraints" title="Permalink to this heading">#</a></h3>
<p>You may have noticed from the previous examples, that we do not provide an explicit method for constraining control rates <span class="math notranslate nohighlight">\(\dot{\vec{U}}\)</span>.
However, this can be accomplished manually by using a custom constraint with phase region <code class="code docutils literal notranslate"><span class="pre">'PairWisePath'</span></code>.
For example, if we wanted to bound the rates of the control variables (<code class="code docutils literal notranslate"><span class="pre">[7,8,9]</span></code> in this example) to be between -1 and 1, we could do so with the following code.
<code class="code docutils literal notranslate"><span class="pre">'PairWisePath'</span></code> will, as the name suggests, call our <code class="code docutils literal notranslate"><span class="pre">URateBound</span></code> function at every sequential pair of time-varying states in the trajectory, thus allowing us to bound a linear estimate of
the control rates from the times and values of the controls.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">URateBound</span><span class="p">(</span><span class="n">LBoundVec</span><span class="p">,</span><span class="n">UBoundVec</span><span class="p">):</span>
    <span class="n">tUtU</span> <span class="o">=</span> <span class="n">Args</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">ti</span><span class="p">,</span><span class="n">Ui</span> <span class="o">=</span> <span class="n">tUtU</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
    <span class="n">tip1</span><span class="p">,</span><span class="n">Uip1</span> <span class="o">=</span> <span class="n">tUtU</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">tip1</span><span class="o">-</span><span class="n">ti</span>
    <span class="n">Urate</span> <span class="o">=</span> <span class="p">(</span><span class="n">Uip1</span><span class="o">-</span><span class="n">Ui</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">UpperBound</span> <span class="o">=</span> <span class="n">Urate</span> <span class="o">-</span> <span class="n">UBoundVec</span>
    <span class="n">LowerBound</span> <span class="o">=</span> <span class="n">LBoundVec</span> <span class="o">-</span> <span class="n">Urate</span>

    <span class="k">return</span> <span class="n">vf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">UpperBound</span><span class="p">,</span><span class="n">LowerBound</span><span class="p">)</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addInequalCon</span><span class="p">(</span><span class="s2">&quot;PairWisePath&quot;</span><span class="p">,</span><span class="n">URateBound</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)),[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
</pre></div>
</div>
<p>It should be noted that for the higher order collocation methods (<code class="code docutils literal notranslate"><span class="pre">LGL5</span></code> and <code class="code docutils literal notranslate"><span class="pre">LGL7</span></code>), the controls are piece-wise quadratic or cubic, so this will not be an exact constraint.
However, in most cases bounding the local linear rate in this way will work just fine. However, we should also note that you should not apply control rate
constraints like the above to phases with <code class="code docutils literal notranslate"><span class="pre">'BlockConstant'</span></code> control parameterization. It will “work” (as in not throw errors or die violently), but it will very likely result in a problem
that is over constrained and structurally singular. Finally, if you need more accurate estimates of the control rates, you always have to option of writing a new ODE where the controls in question are promoted
to state variables and their rates become the new controls.</p>
</section>
<section id="what-happens-if-i-over-constrain-my-problem">
<h3>What happens if I over constrain my problem?<a class="headerlink" href="#what-happens-if-i-over-constrain-my-problem" title="Permalink to this heading">#</a></h3>
<p>We do check that the total number of equality constraints added to a problem (dynamics, mesh-spacing, and user equality constraints) is less than
the total number of variables. However, most cases of over constraining are much more subtle than this and happen when you have added redundant or conflicting
constraints. We do not explicitly check for this at the moment. An example of what we mean by this is illustrated below. Let’s say we needed to constrain the duration
of a phase to be some fixed value, and for the initial time to be equal to 0. We could add a boundary value to the first state in the trajectory to fix the initial time.
Since the initial time is constrained to be 0, fixing the final time to be <code class="code docutils literal notranslate"><span class="pre">dt</span></code> will constrain the phase’s duration as we expect. However, if we were to then accidentally use <code class="code docutils literal notranslate"><span class="pre">.addDeltaTimeEqualCon</span></code>
to fix the phase duration as well, then the problem is over constrained. Thus, you should either fix the initial and final times, or fix the initial time and duration, but not both.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># time is variable 6 for this problem</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">phase</span><span class="o">.</span><span class="n">addBoundaryValue</span><span class="p">(</span><span class="s2">&quot;First&quot;</span><span class="p">,[</span><span class="mi">6</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">])</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addBoundaryValue</span><span class="p">(</span><span class="s2">&quot;Back&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">],[</span><span class="n">dt</span><span class="p">])</span>

<span class="c1">#. Other things that make you forget what you have already done</span>
<span class="c1">#.</span>
<span class="c1">#.</span>
<span class="n">phase</span><span class="o">.</span><span class="n">addDeltaTimeEqualCon</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>  <span class="c1"># BAM!! Over constrained</span>

<span class="n">phase</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>  <span class="c1"># Flying red numbers from the output scroll</span>
</pre></div>
</div>
<p>For problems with controls, mistakes like this will typically not result in an excess of equality constraints, and thus your only indication that something is wrong will be
poor or erratic performance by the optimizer. Sometimes the optimizer’s pivoting perturbation will be able to cope with redundant constraints and return solutions, other times it will
diverge immediately. In conclusion, don’t over constrain your problems…</p>
</section>
<section id="what-happens-if-i-add-multiple-objectives">
<h3>What happens if I add multiple objectives?<a class="headerlink" href="#what-happens-if-i-add-multiple-objectives" title="Permalink to this heading">#</a></h3>
<p>A phase has no restriction of the number of objectives that may be added. If multiple objectives are added, the optimizer will implicitly sum all of their values.</p>
</section>
<section id="bad-initial-guesses">
<h3>Bad Initial Guesses<a class="headerlink" href="#bad-initial-guesses" title="Permalink to this heading">#</a></h3>
<p>By default we take whatever the supplied initial guess to a phase is and use the specified transcription scheme’s interpolation method to generate the initial mesh.
For compressed collocation methods, when the initial guess is very poor, this can induce osculations in the initial interpolated mesh that are not present in the initial guess
. This can be avoided by instead interpolating the initial mesh linearly from the supplied initial guess. You can specify the method for the initial interpolation of a phase as shown below.
If the user supplied initial guess is linear or constant, we recommend using the linear interpolation method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">LerpIG</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1">#Interpolate initial mesh using transcriptions interpolation method (same as default)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="s2">&quot;LGL3&quot;</span><span class="p">,</span><span class="n">TrajIG</span><span class="p">,</span><span class="n">nsegs</span><span class="p">,</span><span class="n">LerpIG</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="s2">&quot;LGL3&quot;</span><span class="p">,</span><span class="n">TrajIG</span><span class="p">,</span><span class="n">nsegs</span><span class="p">)</span> <span class="c1"># Above is the same as this</span>

<span class="n">LerpIG</span> <span class="o">=</span> <span class="kc">True</span>
<span class="c1">#Interpolate initial mesh using linear interpolation</span>
<span class="n">phase</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="s2">&quot;LGL3&quot;</span><span class="p">,</span><span class="n">TrajIG</span><span class="p">,</span><span class="n">nsegs</span><span class="p">,</span><span class="n">LerpIG</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="reintegrating-solutions">
<h3>Reintegrating Solutions<a class="headerlink" href="#reintegrating-solutions" title="Permalink to this heading">#</a></h3>
<p>Reintegration of a phase’s trajectory can be accomplished using an ODE’s integrator and the tabular
form of the solution returned by the <code class="code docutils literal notranslate"><span class="pre">phase.returnTrajTable</span></code> method. To do this, supply the <code class="code docutils literal notranslate"><span class="pre">LGLInterpTable</span></code>
object returned by <code class="code docutils literal notranslate"><span class="pre">returnTrajTable</span></code> to the constructor of the ODE’s integrator type. This will automatically
initialize the integrator to use the control history stored in the trajectory data as a time dependent control law
when integrating. If the control history of the phase is not <code class="code docutils literal notranslate"><span class="pre">&quot;BlockConstant&quot;</span></code>, you can then call <code class="code docutils literal notranslate"><span class="pre">integrate_dense</span></code> to
integrate from the initial full ODE input in the returned trajectory to the final time in the trajectory. This will
still work if the control history was <code class="code docutils literal notranslate"><span class="pre">&quot;BlockConstant&quot;</span></code>, but the result may have small local errors caused by the instantaneous jumps in the control
history at the states where segments adjoin. This can be eliminated by using the second method, which integrates
precisely between each time in the converged trajectory.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ConvTraj</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnTraj</span><span class="p">()</span>
<span class="n">Tab</span>  <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnTrajTable</span><span class="p">()</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">integrator</span><span class="p">(</span><span class="mf">.1</span><span class="p">,</span><span class="n">Tab</span><span class="p">)</span>  <span class="c1"># provide the returned table as arg to integrator</span>
<span class="n">integ</span><span class="o">.</span><span class="n">setAbsTol</span><span class="p">(</span><span class="mf">1.0e-13</span><span class="p">)</span>

<span class="c1"># recall time is variable 6 for this ODE</span>

<span class="c1">## Do this for non-BlockConstant control or if you don&#39;t care about exact accuracy</span>
<span class="c1">## Integrate from initial ODE input to final time</span>
<span class="n">ReintTraj1</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">integrate_dense</span><span class="p">(</span><span class="n">ConvTraj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ConvTraj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">6</span><span class="p">])</span>

<span class="c1">## This is to be preferred if control is BlockConstant</span>
<span class="c1">## Integrate precisely between each time so integrator doesnt see instantaneous jump in control</span>
<span class="n">ReintTraj2</span> <span class="o">=</span> <span class="p">[</span><span class="n">ConvTraj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ConvTraj</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">Next</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">integrate_dense</span><span class="p">(</span><span class="n">ReintTraj2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">ConvTraj</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">6</span><span class="p">])[</span><span class="mi">1</span><span class="p">::]</span>
    <span class="n">ReintTraj2</span><span class="o">+=</span><span class="n">Next</span>
</pre></div>
</div>
</section>
<section id="referencing-and-removing-constraints">
<span id="phaseremove-guide"></span><h3>Referencing and Removing Constraints<a class="headerlink" href="#referencing-and-removing-constraints" title="Permalink to this heading">#</a></h3>
<p>When adding any of the 5 types of constraints/objectives covered <a class="reference internal" href="#conobj-guide"><span class="std std-ref">previously</span></a>, an integer identifier or list of integers is returned by the
method. This identifier can be used to remove a constraint/objective from the problem. This can be quite useful when you
want to express some homotopic or continuation scheme without having to create a new phase at each step. Given the identifier for
a function of a certain type, it can be removed from the phase using the corresponding <code class="code docutils literal notranslate"><span class="pre">.remove#####(id)</span></code> method as shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">###########################</span>
<span class="c1">## Ex. Equality Constraint</span>
<span class="n">edx1</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addBoundaryValue</span><span class="p">(</span><span class="s2">&quot;Front&quot;</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">)))</span>
<span class="n">edx2</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addEqualCon</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="n">edx3</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addDeltaVarEqualCon</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c1">## Removal order doesn&#39;t matter</span>
<span class="n">phase</span><span class="o">.</span><span class="n">removeEqualCon</span><span class="p">(</span><span class="n">edx1</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">removeEqualCon</span><span class="p">(</span><span class="n">edx3</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">removeEqualCon</span><span class="p">(</span><span class="n">edx2</span><span class="p">)</span>


<span class="c1">#############################</span>
<span class="c1">## Ex. Inequality Constraint</span>
<span class="n">idx1</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addInequalCon</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span> <span class="n">Args</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">idx2</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addLUVarBound</span><span class="p">(</span><span class="s2">&quot;StaticParams&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">idx3</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addLUFuncBound</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(),[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">phase</span><span class="o">.</span><span class="n">removeInequalCon</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">removeInequalCon</span><span class="p">(</span><span class="n">idx3</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">removeInequalCon</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span>

<span class="c1">#######################</span>
<span class="c1">## Ex. State Objective</span>
<span class="n">sdx1</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addStateObjective</span><span class="p">(</span><span class="s2">&quot;Back&quot;</span><span class="p">,</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">squared_norm</span><span class="p">(),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">sdx2</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addValueObjective</span><span class="p">(</span><span class="s2">&quot;Back&quot;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">sdx3</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addDeltaTimeObjective</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

<span class="n">phase</span><span class="o">.</span><span class="n">removeStateObjective</span><span class="p">(</span><span class="n">sdx3</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">removeStateObjective</span><span class="p">(</span><span class="n">sdx2</span><span class="p">)</span>
<span class="n">phase</span><span class="o">.</span><span class="n">removeStateObjective</span><span class="p">(</span><span class="n">sdx1</span><span class="p">)</span>


<span class="c1">##########################</span>
<span class="c1">## Ex. Integral Objective</span>
<span class="n">intdx1</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addIntegralObjective</span><span class="p">(</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(),[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>

<span class="n">phase</span><span class="o">.</span><span class="n">removeIntegralObjective</span><span class="p">(</span><span class="n">intdx1</span><span class="p">)</span>

<span class="c1">##########################</span>
<span class="c1">## Ex. Integral Parameter Function</span>
<span class="n">ipdx1</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addIntegralParamFunction</span><span class="p">(</span><span class="n">Args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(),[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span><span class="n">IntSPVar</span><span class="p">)</span>

<span class="n">phase</span><span class="o">.</span><span class="n">removeIntegralParamFunction</span><span class="p">(</span><span class="n">ipdx1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="retrieving-constraint-violations-and-multipliers">
<h3>Retrieving Constraint Violations and Multipliers<a class="headerlink" href="#retrieving-constraint-violations-and-multipliers" title="Permalink to this heading">#</a></h3>
<p>Immediately after a call to PSIOPT, users can retrieve the constraint violations and Lagrange multipliers associated with user applied constraints
as well as the dynamics transcription and control spline constraints. This can be helpful when debugging non-converging problems. For equality and inequality constraints, constraint
violations and multipliers are retrieved by supplying a constraint functions id to the phase’s <code class="code docutils literal notranslate"><span class="pre">.return####Vals(id)</span></code> and <code class="code docutils literal notranslate"><span class="pre">.return####Lmults(id)</span></code> methods as shown below.
In all cases, the violations/multipliers are returned as a list of numpy arrays, each of which contains the output/multipliers associated with each call to the function inside of
the optimization problem. For constraints applied only at a single state, the returned list will contain only one numpy array. In general, for path constraints, the list will contain the same number of elements
as the returned trajectory, and the constraint violations in the ith element will be associated with calling the constraint with variables from the ith state as inputs. Note that for inequality constraints, the return values do not have slacks applied, thus
negative values indicate that the constraint is in the feasible region and positive values indicate that the constraint is in the infeasible region.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edx</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addBoundaryValue</span><span class="p">(</span><span class="s2">&quot;Front&quot;</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">)))</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">addLUVarBound</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>

<span class="n">phase</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

<span class="n">ecvals</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnEqualConVals</span><span class="p">(</span><span class="n">edx</span><span class="p">)</span>
<span class="n">ecmults</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnEqualConLmults</span><span class="p">(</span><span class="n">edx</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">ecvals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ecmults</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="n">icvals</span>  <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnInequalConVals</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="n">icmults</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnInequalConLmults</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

<span class="k">for</span> <span class="n">icval</span><span class="p">,</span><span class="n">icmult</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">icvals</span><span class="p">,</span><span class="n">icmults</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">icval</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">icmult</span><span class="p">)</span>
</pre></div>
</div>
<p>Transcription defect constraint violations can be retrieved with the <code class="code docutils literal notranslate"><span class="pre">.returnTrajError()</span></code> method. Here each element in the returned list
is a numpy array containing the subset of the defect equality constraint errors roughly attributable to the given time. This association is not rigorous or exact,
and is only meant as a guide for roughly determining where the defect constraints become difficult to satisfy. Furthermore, this error is only related to solution
of the optimal control problem, and is not the mesh error estimated by the adaptive mesh refinement scheme (though the two can be correlated). In our formulation, co-states are interpolated directly
from the Lagrange multipliers associated with the transcription defect constraints, so users can use the previously discussed <code class="code docutils literal notranslate"><span class="pre">.returnCostateTraj()</span></code> to examine the behavior of the multipliers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ETraj</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnTrajError</span><span class="p">()</span>

<span class="k">for</span> <span class="n">Et</span> <span class="ow">in</span> <span class="n">ETraj</span><span class="p">:</span>
    <span class="n">Et</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># The defect error</span>
    <span class="n">Et</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>    <span class="c1"># roughly at time t</span>
</pre></div>
</div>
<p>Finally, for the you can also retrieve the constraint values and multipliers for the control spline regularization functions as shown below. If no spline constraints are applied,
the returned lists will be empty.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Usm</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnUSplineConLmults</span><span class="p">()</span>
<span class="n">Usc</span> <span class="o">=</span> <span class="n">phase</span><span class="o">.</span><span class="n">returnUSplineConVals</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="OptimalControlProblem.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Optimal Control Problem Tutorial</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="IntegratorGuide.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Integrator Tutorial</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022-2023, UA ASRL
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Optimal Control Phase Tutorial</a><ul>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#constraints-and-objectives">Constraints and Objectives</a><ul>
<li><a class="reference internal" href="#equality-constraints">Equality Constraints</a></li>
<li><a class="reference internal" href="#inequality-constraints">Inequality Constraints</a></li>
<li><a class="reference internal" href="#state-objectives">State Objectives</a></li>
<li><a class="reference internal" href="#integral-objectives">Integral Objectives</a></li>
<li><a class="reference internal" href="#integral-parameter-functions">Integral Parameter Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#solving-and-optimizing">Solving and Optimizing</a></li>
<li><a class="reference internal" href="#miscellaneous-topics">Miscellaneous Topics</a><ul>
<li><a class="reference internal" href="#shooting-method">Shooting Method</a></li>
<li><a class="reference internal" href="#control-rate-constraints">Control Rate Constraints</a></li>
<li><a class="reference internal" href="#what-happens-if-i-over-constrain-my-problem">What happens if I over constrain my problem?</a></li>
<li><a class="reference internal" href="#what-happens-if-i-add-multiple-objectives">What happens if I add multiple objectives?</a></li>
<li><a class="reference internal" href="#bad-initial-guesses">Bad Initial Guesses</a></li>
<li><a class="reference internal" href="#reintegrating-solutions">Reintegrating Solutions</a></li>
<li><a class="reference internal" href="#referencing-and-removing-constraints">Referencing and Removing Constraints</a></li>
<li><a class="reference internal" href="#retrieving-constraint-violations-and-multipliers">Retrieving Constraint Violations and Multipliers</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>